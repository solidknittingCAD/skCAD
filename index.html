<!DOCTYPE html>
<html>
<head>
<title>Solid Knitting UI</title>
<style>

body.darkmode {
	--far-background-color: #333230;
	--background-color: #232220;
	--background-color-medium: #232220bb;
	--background-color-light: #23222066;
	--background-color-highlight: #dde1;
	--separator-color: #434240;
	--main-font-color: #C4C0AD;
	--far-font-color: #E4E0CD;
	--font-color-highlight: #D4D0CD;
	--link-color: #D1C6B5;

	/* syntax highlighting */
	--comment: #74705D;
	--location: #A6E42C;
	--direction: #AC7DFF;
	--keyword: #FF2275;
	--carrier: #EEEEEE;
	--string: #EDE277;
}

body.lightmode {
	--far-background-color: #d4ccd2;
	--background-color: #fbf8f6;
	--background-color-medium: #f6f0eebb;
	--background-color-light: #f6f0ee66;
	--background-color-highlight: #2221;
	--separator-color: #c4bcc2;
	--main-font-color: #222;
	--far-font-color: #111;
	--font-color-highlight: #222;
	--link-color: #181818;

	/* syntax highlighting, from solarized https://en.wikipedia.org/wiki/Solarized */
	--comment: #839496;
	--location: #2aa198;
	--direction: #268bd2;
	--keyword: #cb4b16;
	--carrier: #073642;
	--string: #b58900;
}

body {
	padding:0;
	margin:0;

	background-color: var(--far-background-color);
	color: var(--far-font-color);
}

body a {
	color: var(--link-color);
}

#dropTarget {
	position:fixed;
	left:0;
	bottom:0;
	width:100%;
	height:100%;

	background:#ccc;
	outline:4px dashed #eee;
	outline-offset:-20px;
	z-index:100;
	visibility:hidden;
}
#dropTarget.active {
	visibility:visible;
	background:#eee;
	outline-color:#ccc;
}
#file {
	display:none;
}

#views {
	display:grid;
/*	width:99vw;*/
	height:99vh;

	grid-template-columns: 1fr auto ;
	grid-template-rows: auto 1.0fr 2em;
	overflow: none;
	grid-gap: 5px;

	/*background: #0008 ;*/
}
#controls {
	grid-column: 1 / 3 ;
	grid-row: 1 ;
	gap: 8px;
	font-size: 16px;
	line-height:16px;
	padding: 5px 5px;
	display:flex;
	flex-flow: row wrap;
	align-items: center;
	/*background: #f008 ;*/
}

.controlsButton {
	box-sizing:border-box;
	cursor:pointer;
	display:inline-block;
	background:#cfbb96;
	padding:4px 8px;
	margin:0;
	box-shadow: 0 1px 2px 0 #0008;
	text-decoration:none;
	line-height:1;
	border: none;
	border-radius:2px;
/*	height:100%;*/
	font-size:inherit;
	font-family: sans-serif;
	color: black;
}

.controlsButton:hover {
	background:#f6d69b;
}

.controlsButton:active {
	box-shadow: 0 0 1px 0 #0008;
}

.controlsInfo {
	display:block;
	text-align:right;
	flex-grow: 1;
}
.controlsInfo + .controlsInfo {
	flex-grow: 0;
}

.controls-section {
	margin-left: 1em;
}

#view-3d {
	grid-column: 1 ;
	grid-row: 2 ;
	/*background: #0f08 ;*/
	display: grid;
	grid-template-rows: auto 1fr;
	grid-template-columns: 1fr;

	color: var(--main-font-color);
}
#canvas-wrapper {
	position:relative;
	overflow: hidden;
	background-color: var(--background-color);
	border-top: solid 2pt var(--separator-color);
	border-radius: 0 5px 5px 0;
}
#canvas {
	position:absolute;
	top:0;
	left:0;
	width:100%;
	height:100%;
	background-color: var(--background-color);
}
#status-line {
	position:absolute;
	left:0;
	bottom:0;
	background:#fff8;
	color: black;
	padding: 0.15em 0.3em;
}
#darkmode-checkbox {
	width: 0;
	height: 0;
	visibility: hidden;
}

body.darkmode #darkmode-checkbox-label::after {
	content: "\263C";
}
body.lightmode #darkmode-checkbox-label::after {
	content: "\263D";
}

#render-options {
	padding: 0 0.5em;
	position: absolute;
	top: 0;
	left: 0;
	background: var(--background-color-medium);

}
#render-options > summary {
	cursor:pointer;
	font-size: 2em;
	list-style: none;
}
#render-options > summary:hover {
	color: var(--font-color-highlight);
}
#render-options > summary::-webkit-details-marker { /* hide details triangle https://stackoverflow.com/a/56649741 */
 	display: none;
}

#sidebar {
	grid-column: 2 ;
	grid-row: 2 ;

	display:grid;
	grid-template-rows: min-content 1fr min-content;
	grid-gap: 5px;

	width: 24em;
	min-height: 0; /* don't expand past parent height https://stackoverflow.com/a/43312314 */
/*	background: #00f8 ;*/

	color: var(--main-font-color);
	background-color: var(--far-background-color);
}
.tab-menu-container {
	margin: 0;
	margin-left: 0.25em;
	padding: 0;
	display: grid;
	box-sizing: border-box;
	grid-template-columns: auto 1fr auto;
	grid-template-rows: auto;

	align-items: center; /* center-align text in menu items */
	background-color: var(--far-background-color);
	color: var(--far-font-color);
}

.tab-menu span {
	padding: 0.25em 0.5em;
}

.tab-menu {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
	display: grid;
	grid-template-rows: 1fr;
	grid-template-columns: repeat(8, max-content);
	grid-gap: 1pt;
}
.tab-menu input[type=radio] { /* invisible radio button to save state https://stackoverflow.com/a/8037883 */
	visibility: hidden;
	width: 0;
	height: 0;
	margin: 0;
	padding: 0;
}
.tab-menu label {
	border: 0;
	font-family: sans-serif;
	border-radius: 0.25em 0.25em 0 0;
	padding: 0.5em 1em 0.25em 1em;
	border: solid 2pt var(--separator-color);
	border-bottom-style: none;
	cursor: pointer;
	background-color: var(--background-color-light);
}
.tab-menu label:hover {
	background-color: var(--background-color-medium);
}
.tab-menu label.active {
	background-color: var(--background-color);
	border-bottom: solid 2pt var(--background-color);
	margin-bottom: -2pt;
	z-index: 1;
}
#sidebar h2, #sidebar summary {
	font-size:20px;
	font-weight: bold;
	line-height:20px;
	padding: 0;
	margin: 0;
	margin-bottom: 0.5em;
	font-family: sans-serif;
	cursor: pointer;
}
#status {
/*	grid-row: 2 ;*/
	margin: 0;
	min-height: 0;
	display: grid; /* set to grid from javascript later too */
	grid-template-rows: auto 1fr;

	padding: 0.5em 0 0.25em 0.25em; /* top right bottom left */
	border-radius: 5px;
	background-color: var(--background-color);
}
#status-text {
	margin:0;
	padding: 0 0 0.5em 0; /* top right bottom left */
}
#library {
/*	grid-row: 2 ;*/
	margin:0;
	padding: 0.5em 0 0 0.5em; /* top right bottom left */
	min-height: 0;
	display:grid; /* set to grid from javascript later too */
	grid-template-rows: auto 1fr;
	padding-bottom: 0.5em;
/*	border-left: 2pt solid var(--separator-color);*/
	border-radius: 5px 0 0 5px;
	background-color: var(--background-color);
	margin-top: -5px;
	border-top: solid 2pt var(--separator-color);
}
#library-list {
/*	grid-row: 2 ;*/
	margin:0;
	padding:0;
	min-width: 0;
	min-height: 0;
	overflow-y: scroll;
}
#library ul {
	list-style:none;
}
#library li {
	display:block;
	margin:0em 0.15em;
	padding:0.15em 0.5em;
	border-radius:0.2em;
	cursor:pointer;
	border: 1pt solid var(--background-color);
}
#library li:hover {
	background-color: var(--background-color-highlight);
	color: var(--font-color-highlight);
}
#library .library-active-template {
	background-color: var(--background-color-highlight);
	color: var(--font-color-highlight);
	border: 1pt solid var(--separator-color);
}
#view-shortcuts {
	/*border-top: 2px solid var(--separator-color);
	border-left: 2pt solid var(--separator-color);*/
	padding: 0.5em 0 0.25em 0.25em; /* top right bottom left */
	border-radius: 5px;
	background-color: var(--background-color);
}
#view-shortcuts summary {
	padding-left: 0.5em;
	margin: 0;
	margin-bottom: 0.5em;
}
#shortcuts {
	grid-row: 3 ;
	margin:0;
	padding:0;
}
#shortcuts li {
	display:block;
	margin:0.1em 0.15em;
	padding:0.0em 0.5em;
}
#shortcuts .key {
	font-family: monospace;
}
#view-knitout {
	margin: 0;
	padding: 0;
	overflow: auto;
	display:grid; /* set to grid from javascript later too */
	grid-template-rows: 1fr auto;
/*	border-left: 2pt solid var(--separator-color);*/
	border-radius: 5px 0 0 5px;
	background-color: var(--background-color);
	margin-top: -5px;
	border-top: solid 2pt var(--separator-color);
}
#view-knitout #view-knitout-options {
	padding: 0.5em 1em;
	background-color: var(--background-color);
}
#knitout-source {
	font-family: monospace;
	padding-top: 0.5em;
	min-height: 0;
	overflow-y: scroll;
	margin-bottom: 0.5em;
/*	background-color: #272822;*/
}
/* code styling */
#knitout-source span {
	/* position: relative; /* for tooltips */
	 white-space: pre-wrap; /* preserve whitespace but allow line wrapping */
}

/* https://www.w3schools.com/css/css_tooltip.asp */
/*#knitout-source span .tooltiptext {
	visibility: hidden;
	position: absolute;
	z-index: 1;
	background-color: #202010;
	padding: 0.5em 1em;
	color: white;
	top: 0;
	left: 4em;
	border: 1pt solid #555;
	border-radius: 0.25em;
}
#knitout-source span:hover .tooltiptext {
	visibility: visible;
}*/
#knitout-source .line {
	padding: 0 0;
	display: flex;
}
#knitout-source .line-number {
	color: #94908D;
	width: 2em;
	padding: 0 0.5em;
	display: inline-block;

	/* disable selection: https://stackoverflow.com/a/4407335 */
	-webkit-touch-callout: none; /* iOS Safari */
	-webkit-user-select: none; /* Safari */
	 -khtml-user-select: none; /* Konqueror HTML */
	   -moz-user-select: none; /* Old versions of Firefox */
	    -ms-user-select: none; /* Internet Explorer/Edge */
	        user-select: none; /* Non-prefixed version, currently
	                              supported by Chrome, Edge, Opera and Firefox */
}
#knitout-source .line:hover {
	color: #C4C0BD;
	background-color: var(--background-color-highlight);
}
#knitout-source .code {
	border-left: 2px solid var(--separator-color);
/*	box-shadow: inset 8px 0 8px -10px black;*/
	padding-left: 0.5em;
	width: 100%;
}
#knitout-source .comment {
	color: var(--comment);
}
#knitout-source .location {
	color: var(--location);
}
#knitout-source .direction {
	color: var(--direction);
}
#knitout-source .keyword {
	color: var(--keyword);
}
#knitout-source .carrier {
	color: var(--carrier);
}
#knitout-source .string {
	color: var(--string);
}

#view-block-data {
	display: grid; /* set to grid from javascript later too */
	grid-template-rows: auto 1fr;
	gap: 0;
	padding: 0.5em 0 0 0.25em; /* top right bottom left */
	/*border-top: 2pt solid var(--separator-color);
	border-left: 2pt solid var(--separator-color);*/
	border-radius: 5px 0 0 5px;
	background-color: var(--background-color);
}
#view-block-data summary {
	padding-left: 0.5em;
	margin: 0;
	margin-bottom: 0.5em;
}
#hovered-block-info {
	display: grid;
	grid-template-columns: auto 1fr;
	grid-template-rows: max-content;
	align-content: start;
	gap: 0;
	align-items: stretch;
}
/* shade every other row https://stackoverflow.com/a/44937583 */
#hovered-block-info > :nth-child(4n+1), #hovered-block-info > :nth-child(4n+2) {
	background-color: var(--background-color-highlight);
}
#hovered-block-info .field-name {
	padding: 0.15em 0.25em 0.15em 0.5em; /* top right bottom left */
	min-height: 0;
	display: inline-flex;
	align-items: center;         /* vertically-center text */
	justify-content: flex-end;   /* align right */
}
#hovered-block-info .field-name:after {
	content: ":";
}
#hovered-block-info .field-value {
	padding: 0.25em 1em 0.25em 0.5em; /* top right bottom left */
	font-family: monospace;
}
#hovered-block-info input[type=text] {
	font-family: monospace;
	width: 100%;
	border: none;
	background-color: #fff1;
	color: var(--main-font-color);
	border-radius: 2pt;
	border: 1pt var(--separator-color) solid;
}
#message-box {
	grid-column: 1 / 3 ;
	grid-row: 3 ;
	margin: 0;
	min-height: 0;

	padding: 0.5em 0 0.25em 0.25em; /* top right bottom left */
	border-radius: 5px;
	background-color: var(--background-color);
}
</style>
</head>
<body class="lightmode">

<div id="views">

<!-- controls bar at the top of the window -->
<div id="controls">

<button id="edit-path" class="controlsButton">Edit/Pattern</button>
<button id="indicate-loop" class="controlsButton">Indicate Loop</button>
<input id="load-stl" type="file" style="display:none" />
<!-- <label id="load-stl-label" for="load-stl" class="controlsButton">Load STL</label> -->
<!-- <input id="voxelize" type="file" style="display:none" />
<label id="voxelize-label" for="voxelize" class="controlsButton">Voxelize</label> -->
<button id="voxelize" class="controlsButton"><!-- Voxelize --></button> <!-- commented out for workshop -->

<input id="file" type="file" />
<label id="fileLabel" for="file" class="controlsButton">Load</label>
<!-- <button id="benchmark">benchmark</button>
<span id="benchmark-result"></span> -->
<button id="save" class="controlsButton">Save</button>

<button id="save-yarn-path" class="controlsButton">Save Yarn Path</button>
<button id="save-knitout" class="controlsButton"><!--Save Knitout--></button>  <!-- commented out for workshop -->	
<!-- <button id="reallocate-spots" class="controlsButton">Reallocate Needle Locations</button> -->
<!-- <span class="controlsInfo"><a href="https://github.com/textiles-lab/solid-knitting-ui/">github page</a>;</span>
<span class="controlsInfo"><a href="https://github.com/textiles-lab/solid-knitting-ui/issues">report a bug</a></span> -->

</div>

<!-- 3d view -->
<div id="view-3d">
	<div id="viewmode-options" class="tab-menu-container">
		<span id="fileName">(no file loaded)</span>
		<form id="select-3dview-mode" class="tab-menu">
			<input type="radio" name="3dview-mode" id="3dview-pattern-mode" value="Pattern" checked><label id="3dview-set-pattern-mode" for="3dview-pattern-mode" class="tab">Pattern</label><input type="radio" name="3dview-mode" id="3dview-template-mode" value="Template" class="tab"><label id="3dview-set-template-mode" for="3dview-template-mode">Templates</label>
		</form>
		<form id="darkmode-toggle">
			<input type="checkbox" id="darkmode-checkbox" name="darkmode" value="darkmode" checked><label for="darkmode-checkbox" id="darkmode-checkbox-label"></label>
		</form>
	</div>
	<div id="canvas-wrapper">
		<canvas id="canvas" width="120" height="120"></canvas>
		<div id="status-line">(Status Line)</div>
		<details id="render-options">
			<summary>&#9881;</summary>
			<div id="yarn-vis-options" class="controls-section">
				Yarn Visualization:
				<select id="select-yarn-vis-option">
					<option value="Tube" selected>Tube</option>
					<option value="Wire">Wire</option>
					<option value="Body">Body</option>
				</select>
			</div>
			<!-- cell-based layer visibility -->
			<!-- <div id="layer-visibility-options" class="controls-section"> -->
			<div id="layer-visibility-options" class="controls-section" style="display:none;"> <!-- uncomment this line to hide -->
				Layer Visibility:
				<form id="layer-visibility-form" style="display:inline-block;">
					<input type="checkbox" name="layer-visible" value="0" checked>1
					<input type="checkbox" name="layer-visible" value="1" checked>2
					<input type="checkbox" name="layer-visible" value="2" checked>3
					<input type="checkbox" name="layer-visible" value="3" checked>4
					<input type="checkbox" name="layer-visible" value="4" checked>5
					<input type="checkbox" name="layer-visible" value="5" checked>6
					<input type="checkbox" name="layer-visible" value="6" checked>7
					<input type="checkbox" name="layer-visible" value="7" checked>8
					<input type="checkbox" name="layer-visible" value="8" checked>9
					<input type="checkbox" name="layer-visible" value="9" checked>10
					<input type="checkbox" name="layer-visible" value="10" checked>11
					<input type="checkbox" name="layer-visible" value="11" checked>12
					<input type="checkbox" name="layer-visible" value="12" checked>13
					<input type="checkbox" name="layer-visible" value="13" checked>14
					<input type="checkbox" name="layer-visible" value="14" checked>15
					<input type="checkbox" name="layer-visible" value="15" checked>16
					<input type="checkbox" name="layer-visible" value="16" checked>17
					<input type="checkbox" name="layer-visible" value="17" checked>18
					<input type="checkbox" name="layer-visible" value="18" checked>19
					<input type="checkbox" name="layer-visible" value="19" checked>20
				</form>
			</div>
			<!-- yarn-based layer visibility -->
			<div id="layer-visibility-yarn-options" class="controls-section">
				Layer Visibility:
				<form id="layer-visibility-yarn-form" style="display:inline-block;">
					<input type="checkbox" name="layer-visibility-yarn" value="0" checked>1
					<input type="checkbox" name="layer-visibility-yarn" value="1" checked>2
					<input type="checkbox" name="layer-visibility-yarn" value="2" checked>3
					<input type="checkbox" name="layer-visibility-yarn" value="3" checked>4
					<input type="checkbox" name="layer-visibility-yarn" value="4" checked>5
					<input type="checkbox" name="layer-visibility-yarn" value="5" checked>6
					<input type="checkbox" name="layer-visibility-yarn" value="6" checked>7
					<input type="checkbox" name="layer-visibility-yarn" value="7" checked>8
					<input type="checkbox" name="layer-visibility-yarn" value="8" checked>9
					<input type="checkbox" name="layer-visibility-yarn" value="9" checked>10
					<input type="checkbox" name="layer-visibility-yarn" value="10" checked>11
					<input type="checkbox" name="layer-visibility-yarn" value="11" checked>12
					<input type="checkbox" name="layer-visibility-yarn" value="12" checked>13
					<input type="checkbox" name="layer-visibility-yarn" value="13" checked>14
					<input type="checkbox" name="layer-visibility-yarn" value="14" checked>15
					<input type="checkbox" name="layer-visibility-yarn" value="15" checked>16
					<input type="checkbox" name="layer-visibility-yarn" value="16" checked>17
					<input type="checkbox" name="layer-visibility-yarn" value="17" checked>18
					<input type="checkbox" name="layer-visibility-yarn" value="18" checked>19
					<input type="checkbox" name="layer-visibility-yarn" value="19" checked>20
				</form>
			</div>
			<div id="yarn-direction-vis-options" class="controls-section">
				<form id="show-yarn-direction-form" style="display:inline-block;">
					<input type="checkbox" name="show-yarn-direction" value="0"> Show Yarn Direction
				</form>
			</div>
		</details>
	</div>
</div>

<!-- library panel -->
<div id="sidebar">
<div id="sidebar-menu" class="tab-menu-container">
	<form id="select-sidebar-mode" class="tab-menu">
		<input type="radio" name="sidebar-mode" id="sidebar-design-mode" value="PatternDesign" checked><label id="sidebar-set-design-mode" for="sidebar-design-mode" class="tab">Pattern Design</label><input type="radio" name="sidebar-mode" id="sidebar-codegen-mode" value="CodeGen"><label id="sidebar-set-codegen-mode" for="sidebar-codegen-mode" class="tab">Code Generation</label>
	</form>
</div>
<div id="library">
<h2>Block Library:</h2>
<ul id="library-list">
</ul>
</div>

<!-- preview generated knitout -->
<div id="view-knitout">
	<div id="view-knitout-options">
		<form id="group-knitout-passes-form" style="display:inline-block;">
		<label for="group-knitout-passes">Group knitout passes:</label>
		<input type="checkbox" name="group-knitout-passes">
		</form>
		<button id="regenerate-code" class="controlsButton">Regenerate Code</button>
	</div>
	<div id="knitout-source"></div>
</div>

<!-- see information about highlighted block -->
<details id="view-block-data" open>
	<summary> Block Info:</summary>
	<form id="hovered-block-info"></form>
</details>

<!-- also list shortcuts -->
<details id="view-shortcuts" open>
<summary>Commands:</summary>
<ul id="shortcuts">
	<li> <button class="controlsButton" id="relax-shape">Relax shape</button> (<span class="key">space</span> or <span class="key">R</span>)</li>
	<li> <button class="controlsButton" id="select-hovered-template">Select hovered template</button> (<span class="key">D</span>)</li>
	<li> <button class="controlsButton" id="delete">Delete cell</button> (<span class="key">X</span>)</li>
	<li> <button class="controlsButton" id="grab">Grab cell</button> (<span class="key">G</span>)</li>
	<li> <button class="controlsButton" id="add">Add cell</button> (<span class="key">A</span>)</li>
	<li> <button class="controlsButton" id="extrude">Extrude cell</button> (<span class="key">E</span>)</li>
	<li> <button class="controlsButton" id="extrude-contiguous">Extrude contiguous faces</button> (<span class="key">W</span>)</li>
	<li> <button class="controlsButton" id="start-connection">Start/make connection</button> (<span class="key">C</span>)</li>
	<li> <button class="controlsButton" id="prev-template">Prev template</button> (<span class="key">up</span>)</li>
	<li> <button class="controlsButton" id="next-template">Next template</button> (<span class="key">down</span>)</li>
	<li> <button class="controlsButton" id="prev-compatible-template">Prev compatible template</button> (<span class="key">K</span>)</li>
	<li> <button class="controlsButton" id="next-compatible-template">Next compatible template</button> (<span class="key">J</span>)</li>
	<li> <button class="controlsButton" id="select-hovered-block">Select hovered block</button> (<span class="key">S</span>)</li>
	<li> <button class="controlsButton" id="undo">Undo</button> (<span class="key">ctrl-Z</span>)</li>
	<li> <button class="controlsButton" id="escape-from-action">Escape from grab/connect/selection</button> (<span class="key">esc</span>)</li>
</ul>
</details>
</div>

<div id="message-box">	
	<div id="cycle-text"></div>
	<div id="yarn-count-text"></div>
</div>



<!-- full-window drop target -->
<div id="dropTarget"></div>

<!-- File loading code -->
<script>

// clarity. 
//-----------------------------------------------------------------------------
// File loading code

window.currentFile = null;

function setFilename(name) {
	document.getElementById("fileName").textContent = name;
}
function readFile(file) {
	console.log("Attempting to read file: '" + file.name + "'");
	setFilename(file.name);

	if (readFile.reader) {
		readFile.reader.abort();
		delete readFile.reader;
	}

	let reader = readFile.reader = new FileReader();
	reader.onload = function(){
		console.log("File was " + reader.result.byteLength + " bytes long.");
		window.body = sv.Body.fromArrayBuffer(reader.result, library);

		bodyDirty();
		cursorDirty();
		resetCamera();
		requestRedraw();
		window.currentFile = file;
	};
	reader.readAsArrayBuffer(file);
}

var dropTarget = document.getElementById("dropTarget");
//dragging into the window also loads files:
dropTarget.addEventListener('dragover', function(evt){
	dropTarget.classList.add("active");
	evt.preventDefault();
	return false;
});
dropTarget.addEventListener('dragleave', function(evt){
	dropTarget.classList.remove("active");
	evt.preventDefault();
	return false;
});
dropTarget.addEventListener('drop', function(evt){
	dropTarget.classList.remove("active");
	try {
		file.value = "";
		window.currentFile = null;
		readFile(evt.dataTransfer.files[0]);
	} catch (e) {
		console.log(e);
	}
	evt.preventDefault();
	return false;
});

//dragging into the window shows the target:
document.addEventListener('dragover', function(evt){
	dropTarget.classList.add("active");
	evt.preventDefault();
	return false;
});

var file = document.getElementById("file");
file.addEventListener('change', function(evt){
	try {
		window.currentFile = null;
		readFile(file.files[0]);
	} catch (e) {
		console.log(e);
	}
	evt.preventDefault();
	return false;
});
file.addEventListener('click', function(evt){
	file.value = ""; //reset so 'change' event fires
});

document.getElementById("save").addEventListener('click', function(evt){
	console.log("Saving");
	const text = JSON.stringify(body.toData());
	fileSave(text, "solid-knitting.body");
});
document.getElementById("save-yarn-path").addEventListener('click', function(evt){
	console.log("Saving yarn path");
	let text = "";
	let iV = 1;
	for (const cell of body.cells) {
		const xf = cell.xform;
		for (const yarn of cell.template.yarns) {
			for (let iP=0; iP<yarn.pts.length; ++iP) {
				const pt = yarn.pts[iP];
				let at = gm.mul_mat4x3_vec4(xf, [...pt, 1]);
				text += "v " + at[0]  + " " + at[1] + " " + at[2] + "\n";
			}
			text += "l ";
			for (let iP=0; iP<yarn.pts.length; ++iP) {
				text += iV + " ";
				++iV;
			}
			text += "\n";
		}

	}
	fileSave(text, "solid-knitting-yarn-path.obj");
});

//from knitout-live-visualizer:
function fileSave(sourceText, fileIdentity) {
	var workElement = document.createElement("a");
	if ('download' in workElement) {
		workElement.href = "data:" + 'text/plain' + "charset=utf-8," + escape(sourceText);
		workElement.setAttribute("download", fileIdentity);
		document.body.appendChild(workElement);
		var eventMouse = document.createEvent("MouseEvents");
		eventMouse.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
		workElement.dispatchEvent(eventMouse);
		document.body.removeChild(workElement);
		console.log(workElement);

		// window.currentFile = file;
	} else throw 'File saving not supported for this browser';
}

</script>

<!-- Solid Knitting UI code -->
<script type="module">
'use strict';

import * as gm from './code/gm.mjs';
window.gm = gm; //DEBUG

import * as sv from './code/sv.mjs';
window.sv = sv; //DEBUG

// window.library = new sv.Library();


// for auto convert
let editPathMode = false;

document.getElementById("edit-path").addEventListener('click', function() {
    editPathMode = !editPathMode;

    if (editPathMode) {
        autoConvertCells();
        this.textContent = "Edit/Pattern";
    } else {
        convertCellsToNullByDirection();

		// Automatically select unlabeled.right.alt template when returning to edit mode
        const unlabeledRightAltTemplate = library.getTemplateByLongname("unlabeled.right.alt");
        if (unlabeledRightAltTemplate) {
            window.template = unlabeledRightAltTemplate;
            setActiveTemplate(unlabeledRightAltTemplate); // reflect to UI
        } else {
            console.error("unlabeled.right.alt template not found in library");
        }
		
        this.textContent = "Edit/Pattern";
    }
    bodyDirty();
});

// for STL import
import {loadLibraryFromURL} from './code/sv.mjs';
window.library = await loadLibraryFromURL("./block-library/blocks.json");


window.template = null;
window.body = new sv.Body();

import {Geometry, Program, loadTexture} from './code/gl.mjs';
import {writeHighlightedCode, groupBlocks, groupPasses, noPassGrouping} from './code/sk.mjs';

document.getElementById("save-knitout").addEventListener('click', function(evt){
	if (groupKnitoutPassesCheckbox.checked) {
		fileSave(groupPasses(knitoutCode.fragments), "solid-knitting-pattern.sk");
	} else {
		fileSave(noPassGrouping(knitoutCode.fragments), "solid-knitting-pattern.sk");	
	}
});

// document.getElementById("reallocate-spots").addEventListener('click', function(evt){
// 	allocateSpots();
// });

//-----------------------------------------------------------------------------
// Adapted from yarn visualizer code (from smobj)
// NOTE: based largely on the MDN WebGL tutorials at:
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL

const canvas = document.getElementById("canvas");
const gl = canvas.getContext('webgl', {alpha:false, antialias:false});
window.gl = gl; //DEBUG

//enable extensions:
const ext_WEBGL_depth_texture = gl.getExtension("WEBGL_depth_texture"); //used for postprocessing

const STATUS_LINE = document.getElementById("status-line");
window.STATUS_LINE = STATUS_LINE;

// "enum" representing possible displays
const ViewMode = {
	Pattern: 'Pattern',
	Template: 'Template'
};
let viewMode = ViewMode.Pattern;
let viewPerspective = true;

//------- camera -------
const camera = {
	target:gm.vec3(0),
	radius:2.5,
	azimuth:0.0,
	elevation:0.0,
	fovy:45.0,
	aspect:1.0
};

window.camera = camera; //DEBUG

camera.computeUp = function camera_computeUp() {
	return gm.vec3(
		Math.cos(this.azimuth)*-Math.sin(this.elevation),
		Math.sin(this.azimuth)*-Math.sin(this.elevation),
		Math.cos(this.elevation)
	);
};

camera.computeRight = function camera_computeRight() {
	return gm.vec3(
		-Math.sin(this.azimuth),
		Math.cos(this.azimuth),
		0.0
	);
};

camera.computeOut = function camera_computeOut() {
	return gm.vec3(
		Math.cos(this.azimuth)*Math.cos(this.elevation),
		Math.sin(this.azimuth)*Math.cos(this.elevation),
		Math.sin(this.elevation)
	);
};

camera.computeAt = function camera_computeAt() {
	return gm.add(this.target, gm.scale(this.radius, this.computeOut()));
};

function resetCamera() {
	let min = gm.vec3(Infinity);
	let max = gm.vec3(-Infinity);

	//TOOD: compute bounding box

	if (min[0] > max[0]) {
		//for now, just some default:
		min[0] = -10.0; min[1] = -10.0; min[2] = -10.0;
		max[0] =  10.0; max[1] =  10.0; max[2] =  10.0;
	}

	camera.target = gm.scale(0.5, gm.add(min,max));

	//console.log("Range: ",min,max);

	camera.radius = 0.5 * (max[1] - min[1]) / Math.tan(0.5 * camera.fovy * Math.PI / 180.0) + 0.5 * (max[2] - min[2]);
	camera.azimuth = - Math.PI / 3.0;
	camera.elevation = Math.PI / 4.0;

	requestRedraw();
}
window.resetCamera = resetCamera;

//--- controls ---

const MOUSE = {x:NaN, y:NaN, over:null, grid:null};
let CURSOR = MOUSE; // <-- if anything is selected, set to selection. Otherwise, set to MOUSE
let ACTION = null; //<-- current action; gets all events if not null

let camFlipX = false; //used for camera rotation control

function mouseRay() {
	const origin = camera.computeAt();

	//compute ray direction through mouse:
	const o = camera.computeOut();
	const r = camera.computeRight();
	const u = camera.computeUp();
	const rh = Math.tan(0.5 * camera.fovy / 180.0 * Math.PI); //half of the image plane height
	const rw = rh * camera.aspect; //half of the image plane width

	const direction = gm.sub( gm.add( gm.scale(rw * MOUSE.x, r), gm.scale(rh * MOUSE.y, u)), o);

	return {origin, direction};
}

function mouseDirty() {
	MOUSE.over = null;
	MOUSE.grid = null;

	MOUSE.dirty = true;
	requestRedraw(); //mouse will be updated as part of redraw
}
window.mouseDirty = mouseDirty;

function cursorDirty() {
	mouseDirty(); // always update MOUSE

	// if CURSOR is frozen, we shouldn't update
	if (CURSOR.frozen) return;

	CURSOR.over = null;
	CURSOR.grid = null;

	CURSOR.dirty = true;

	requestRedraw();
}
window.cursorDirty = cursorDirty;

function bodyDirty() {
	visBody.dirty = true;
	visWire.dirty = true;
	visWireCells.dirty = true;
	visTubes.setDirty();
	visTransparentTubes.setDirty();
	for (let cell of body.cells) {
		cell.dirty = true;
	}
	requestRedraw();
}
window.bodyDirty = bodyDirty;
function bodyClean() {
	for (let cell of body.cells) {
		delete cell.dirty;
	}
}
function cellDirty(cell) {
	visBody.dirty = true;
	visWire.dirty = true;
	visWireCells.dirty = true;
	visTubes.dirty = true;
	visTransparentTubes.dirty = true;
	cell.dirty = true;
	requestRedraw();
}

function templateDirty() {
	visTemplateBody.dirty = true;
	visTemplateWire.dirty = true;
	visTemplateTubes.dirty = true;
	visTemplateWireCells.dirty = true;
	requestRedraw();
}
window.templateDirty = templateDirty;

function knitoutDirty() {
	knitoutCode.dirty = true;
	requestRedraw();
}
window.knitoutDirty = knitoutDirty; // for debugging

function setMouseOver() {
	delete MOUSE.dirty;
	MOUSE.over = null;
	MOUSE.grid = null;
	if (MOUSE.x !== MOUSE.x) return;
	const ray = mouseRay();

	let close = Infinity;
	

	//faces of cells:
	function isect(a,b,c, cell,face, cellID) {
		const perp = gm.cross(gm.sub(b, a), gm.sub(c, a));

		//offset of the start of the ray from the plane of the triangle:
		const ofs = gm.dot(perp, gm.sub(ray.origin, a));

		//change in offset when moving along direction:
		const step = gm.dot(perp, ray.direction);

		//if can't get to plane of triangle, can't intersect:
		if (step === 0) return;
		if (ofs <= 0 && step <= 0) return;
		if (ofs >= 0 && step >= 0) return;

		//if can't get to plane in time, can't intersect:
		const t = -ofs / step;
		if (t >= close) return;

		//move point to plane of triangle:
		const p = gm.add(ray.origin, gm.scale(t, ray.direction));

		//console.log(`Close to zero(?): ${dot(perp, sub(p,a))}`); //DEBUG

		//barycentric coords:
		const wa = gm.dot(perp, gm.cross(gm.sub(c,b), gm.sub(p,b)));
		const wb = gm.dot(perp, gm.cross(gm.sub(a,c), gm.sub(p,c)));
		const wc = gm.dot(perp, gm.cross(gm.sub(b,a), gm.sub(p,a)));

		//outside the triangle:
		if (wa < 0 || wb < 0 || wc < 0) return;

		close = t;
		MOUSE.over = {cell, face, cellID};
		MOUSE.grid = null;
	}

	for (let cellID = 0; cellID < body.cells.length; ++cellID) {
		const cell = body.cells[cellID];
		if (!checkCellVisible(cell)) continue;
		{ //ray vs bounding box of cell:
			let min = gm.vec3(Infinity);
			let max = gm.vec3(-Infinity);
			for (let v of cell.vertices) {
				min = gm.min(min, v);
				max = gm.max(max, v);
			}
			let t0 = 0;
			let t1 = Infinity;
			function reduce(low, high, origin, direction) {
				//when is low <= origin + t * direction <= high?
				if (direction > 0) {
					t0 = Math.max(t0, (low - origin) / direction);
					t1 = Math.min(t1, (high - origin) / direction);
				} else if (direction < 0) {
					t1 = Math.min(t1, (low - origin) / direction);
					t0 = Math.max(t0, (high - origin) / direction);
				} else {
					if (origin < low || origin > high) {
						t0 = 1;
						t1 = 0;
					}
				}
			}
			for (let d = 0; d < 3; ++d) {
				reduce(min[d], max[d], ray.origin[d], ray.direction[d]);
			}
			if (t0 > t1) continue; //if doesn't intersect bounding box
		}

		for (let fi = 0; fi < cell.template.faces.length; ++fi) {
			const face = cell.template.faces[fi];
			for (let i = 2; i < face.indices.length; ++i) {
				const a = cell.vertices[face.indices[0]];
				const b = cell.vertices[face.indices[i-1]];
				const c = cell.vertices[face.indices[i]];
				isect(a,b,c, cell,fi, cellID);
			}
		}
	}

	//also check grid (at z = 0) [but only if not over a face]:
	if (MOUSE.over === null) {
		const ofs = ray.origin[2];
		const step = ray.direction[2];
		if ((ofs < 0 && step > 0) || (ofs > 0 && step < 0)) {
			const t = -ofs / step;
			if (t < close) {
				close = t;
				MOUSE.over = null;
				MOUSE.grid = {
					x:ray.origin[0] + ray.direction[0] * t,
					y:ray.origin[1] + ray.direction[1] * t,
					z:ray.origin[2] + ray.direction[2] * t
				};
			}
		}
	}

}

function setCursorOver() {
	delete CURSOR.dirty;
	setMouseOver(); // update mouse position
	if (CURSOR.frozen) {
		// if a location is selected, do nothing
	} else {
		// otherwise, deep copy mouse position
		CURSOR = {x: MOUSE.x, y: MOUSE.y, over: MOUSE.over, grid: MOUSE.grid};
	}
}

//mouse in elt-is-[-1,1]x[-1,1] space:
function relativeMouse(evt, elt) {
	//based on: https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event
	const rect = elt.getBoundingClientRect();
	return {
		x:2.0 * (evt.clientX - rect.left) / rect.width - 1.0,
		y:-2.0 * (evt.clientY - rect.top) / rect.height + 1.0
	};
}

/* set CURSOR to cell, face pair. Does not store action in undo queue */
function unsafeSelectFace(cell, face) {
	if (cell == null || face == null) return;

	const cellID = body.cells.indexOf(cell);
	const newCursor = {x: null, y: null, over: {cell, face, cellID}, grid: null, frozen: true};
	CURSOR = newCursor;
}

function selectMouseOver() {
	const oldCursor = storeCursor(CURSOR);

	CURSOR.frozen = false; // unfreeze cursor so that we select even if something is already selected
	setCursorOver();
	CURSOR.frozen = true;
	const newCursor = {x: CURSOR.x, y: CURSOR.y, over: CURSOR.over, grid: CURSOR.grid, frozen: true};

	pushCommand({type: "Select", oldCursor: oldCursor, newCursor: storeCursor(newCursor)});
}

canvas.addEventListener('wheel', function(evt){
	evt.preventDefault();
	let amt = evt.deltaY;
	if (evt.deltaMode === 0x01) amt *= 16.0;
	const zoom = Math.pow(0.5, -0.003 * amt);
	camera.radius *= zoom;
	if (camera.radius < 1.0) camera.radius = 1.0;
	if (camera.radius > 1000.0) camera.radius = 1000.0;
	requestRedraw();
});

canvas.addEventListener('mousedown', function(evt){
	const mouse = relativeMouse(evt, canvas);
	if (ACTION) {
		if (ACTION.mousedown) ACTION.mousedown(evt, mouse);
	} else {
		if (evt.button == 0) {
            startCameraMove();
		}
	}
	MOUSE.x = mouse.x;
	MOUSE.y = mouse.y;
	cursorDirty();
	evt.preventDefault();
});

canvas.addEventListener('mousemove', function(evt){
	const mouse = relativeMouse(evt, canvas);
	if (ACTION) {
		if (ACTION.mousemove) ACTION.mousemove(evt, mouse);
	} else {
		//generally, nothing
	}
	MOUSE.x = mouse.x;
	MOUSE.y = mouse.y;
	cursorDirty();
	evt.preventDefault();
});

canvas.addEventListener('mouseup', function(evt){
	const mouse = relativeMouse(evt, canvas);
	if (ACTION) {
		if (ACTION.mouseup) ACTION.mouseup(evt, mouse);
	} else {
		//generally, nothing
	}
	MOUSE.x = mouse.x;
	MOUSE.y = mouse.y;
	cursorDirty();
	evt.preventDefault();
});

/**
 * detectCycles():
 * Checks pattern for cycles and updates UI with result
 */
function detectCycles() {
	// probably will change keycode. 
	// Run topological sort. 
	if (!checkGlobalCellCorrectness()){
		document.getElementById("cycle-text").innerHTML = "Warning: There is exists a cycle in yarn directions!";
	} else {
		document.getElementById("cycle-text").innerHTML = "No cycles detected in yarn directions.";
	}
}

// set up command buttons
document.getElementById("relax-shape").onclick = function () { body.relax(); bodyDirty(); };
document.getElementById("select-hovered-template").onclick = function () {
	if (CURSOR.over) {
		setActiveTemplate(CURSOR.over.cell.template);
		requestRedraw();
	} else {
		setActiveTemplate(null);
		requestRedraw();
	}
};
document.getElementById("delete").onclick = function () {
	deleteCell();
	delete CURSOR.frozen;
	cursorDirty();
};
document.getElementById("grab").onclick = startGrabCell;
document.getElementById("add").onclick = addCell;
document.getElementById("extrude").onclick = extrudeSelected;
document.getElementById("extrude-contiguous").onclick = extrudeContiguous;
document.getElementById("start-connection").onclick = function () {
	if (ACTION) {
		if (ACTION.type === "Connect") {
			ACTION.keydown({code: "KeyC"});
		}
	} else {
		startConnectFace();
	}
}
document.getElementById("prev-template").onclick = function () {
	prevTemplate();
	requestRedraw();
};
document.getElementById("next-template").onclick = function () {
	nextTemplate();
	requestRedraw();
};
document.getElementById("prev-compatible-template").onclick = function () {
	prevCompatibleTemplate();
	requestRedraw();
};
document.getElementById("next-compatible-template").onclick = function () {
	nextCompatibleTemplate();
	requestRedraw();
};
document.getElementById("select-hovered-block").onclick = function () {
	selectMouseOver();
	requestRedraw();
};
document.getElementById("undo").onclick = undoLatestCommand;
document.getElementById("escape-from-action").onclick = function () {
	if (ACTION) {
		ACTION.keydown({code : 'Escape'});
	} else if (CURSOR.frozen) {
		delete CURSOR.frozen;
		cursorDirty();
	}
};

window.addEventListener('keydown', function(evt) {
	// ignore keypresses if an input is selected so that we don't interfere with typing
	if (evt.target.tagName.toLowerCase() === "input") return;

	if (evt.code == 'KeyS') { // selection takes priority over everything since it's helpful during actions
		selectMouseOver();
		requestRedraw();
	} else if (ACTION) { // actions take priority over ordinary keybindings
		if (ACTION.keydown) ACTION.keydown(evt);
	} else {
		if (CURSOR.frozen && evt.code == 'Escape') {
			delete CURSOR.frozen;
			cursorDirty();
		}
		if (evt.code == 'KeyZ' && (evt.ctrlKey || evt.metaKey)) { 
			// allow control-z or command-z on all systems since it seems tricky to check which is expected
			undoLatestCommand();
			return;
		} else if (evt.code === 'Space' || evt.code === 'KeyR') { 
			body.relax();
			bodyDirty();
		} else if (evt.code == 'KeyA') {
			addCell();
		} else if (evt.code == 'KeyE') {
			extrudeSelected();
		} else if (evt.code == 'KeyW') {
			extrudeContiguous();
		} else if (evt.code == 'KeyD') {
			if (CURSOR.over) {
				setActiveTemplate(CURSOR.over.cell.template);
				requestRedraw();
			} else {
				setActiveTemplate(null);
				requestRedraw();
			}
		} else if (evt.code == 'KeyX') {
			deleteCell();
			delete CURSOR.frozen;
			cursorDirty();
		} else if (evt.code == 'KeyG') {
			startGrabCell(); //start drag
		} else if (evt.code == 'KeyC') {
			// warning: keybinding also hardcoded into action and button
			startConnectFace(); //start connection
		} else if (evt.code == 'KeyU') {
			// probably will change keycode. 
			// Run topological sort. 
			if (!checkGlobalCellCorrectness()) console.log("Warning: There is exists a cycle in yarn directions!");
			else console.log("No cycles detected in yarn directions");
		} else if (evt.code == 'ArrowUp') {
			prevTemplate();
			requestRedraw();
		} else if (evt.code == 'ArrowDown') {
			nextTemplate();
			requestRedraw();
		} else if (evt.code == 'KeyJ') {
			nextCompatibleTemplate();
			requestRedraw();
		} else if (evt.code == 'KeyK') {
			prevCompatibleTemplate();
			requestRedraw();
		} else if (evt.key === '5') {
			viewPerspective = !viewPerspective;
			requestRedraw();
		} else if (evt.key === '1') {
			viewFront();
			requestRedraw();
		} else if (evt.key === '3') {
			viewSide();
			requestRedraw();
		} else if (evt.key === '7') {
			viewTop();
			requestRedraw();
		} else if (evt.key === 'ArrowLeft') { // skCAD
			if (indicateLoopMode) {
				selectedLoopIndex = Math.max(0, selectedLoopIndex - 1);
				updateLoopIndication();
			}
		} else if (evt.key === 'ArrowRight') { // skCAD
			if (indicateLoopMode) {
				const path = window.path;
				if (path && selectedLoopIndex < path.length - 1) {
					selectedLoopIndex = Math.min(path.length - 1, selectedLoopIndex + 1);
				}
				updateLoopIndication();
			}
		}
		//console.log(evt.code); //when you want more keys
	}
});

// keep track of commands in a circular buffer to implement undo
let commandHistory = {
	commands: Array(50).fill(null),
	latest: 49
};

// records the cursor (but represents cursor.over.cell only using its cellID)
function storeCursor(cursor) {
	if (cursor.over) {
		const cellID = (cursor.over.cellID != null) ? cursor.over.cellID : body.cells.indexOf(cursor.over.cell);
		const storedCursor = {x: cursor.x, y: cursor.y, over: {cellID: cellID, face: cursor.over.face}, grid: cursor.grid};
		if (cursor.frozen) storedCursor.frozen = true;
		return storedCursor;
	} else {
		const storedCursor = {x: cursor.x, y: cursor.y, over: cursor.over, grid: cursor.grid};
		if (cursor.frozen) storedCursor.frozen = true;
		return storedCursor;
	}
}
function restoreCursor(storedCursor) {
	CURSOR = storedCursor;
	if (CURSOR.over) {
		CURSOR.over.cell = body.cells[storedCursor.over.cellID];
	}
}

function pushCommand(command) {
	commandHistory.latest = (commandHistory.latest + 1) % commandHistory.commands.length;
	commandHistory.commands[commandHistory.latest] = command;
}

function undoLatestCommand() {
	const command = commandHistory.commands[commandHistory.latest];
	if (command == null) {
		console.log("reached end of undo history");
		return; // no command to undo
	}
	if (command.type === "addCell") { // {type: "addCell", newCellIndex: newCellIndex, [oldCursor: oldCursor]}
		unsafeDeleteCell(command.newCellIndex);
		if (command.oldCursor != null) {
			restoreCursor(command.oldCursor);
		}
		requestRedraw();
	} else if (command.type === "addMultipleCells") { // {type: "addMultipleCells", newCellIndices: newCellIndices, [oldCursor: oldCursor]}
		for (let iCell of command.newCellIndices.sort().reverse()) { // remove in reverse order to prevent index problems
			unsafeDeleteCell(iCell);
		}
		if (command.oldCursor != null) restoreCursor(command.oldCursor);
	} else if (command.type === "deleteCell") { // {type: "deleteCell", cell: cell, cellIndex: cellIndex}
		unsafeAddCell(command.cell, command.cellIndex);
	} else if (command.type === "confirmGrabCell") {
		console.log("undoing grab");
		// {type: "confirmGrabCell", cellIndex: body.cells.indexOf(cell),
		// 		             startVertices: startVertices, startXform: startXform,
		// 		             endVertices: cell.vertices, endXform: cell.xform}
		const cell = body.cells[command.cellIndex];
		cell.vertices = command.startVertices;
		cell.xform = command.startXform;
		ACTION = null; // just in case
		cellDirty(cell);
	} else if (command.type === "confirmConnect") {
		console.log("undoing connect");
		// {type: "confirmConnect", cellIndex: body.cells.indexOf(cell), face: face, oldConnection: oldConnection}
		const cell = body.cells[command.cellIndex];
		if (cell.connections[command.face]) { // remove created connection
			const toCell = cell.connections[command.face].cell;
			const toFace = cell.connections[command.face].face;
			toCell.connections[toFace] = null;
		}
		cell.connections[command.face] = command.oldConnection; // restore old connection for cell
		if (command.oldConnection) { // restore old connection for cell's neighbor
			command.oldConnection.cell.connections[command.oldConnection.face] = {cell:cell, face:command.face};
		}
		ACTION = null; // just in case
		cellDirty(cell);
	} else if (command.type === "Select") {
		restoreCursor(command.oldCursor);
	} else if (command.type === "editSchedulingData") {
		// {type: "editSchedulingData", cell: over.cell, field: variableName, oldValue: over.cell.schedulingData[variableName], newValue: textInput.value}
		command.cell.schedulingData[command.field] = command.oldValue;
	} else {
		console.error("unknown command type ", command.type, " in command ", command);
		return;
	}

	// erase command and decrement latest
	commandHistory.commands[commandHistory.latest] = null;
	commandHistory.latest = (commandHistory.latest + commandHistory.commands.length - 1) % commandHistory.commands.length;
}



// clarity. 

// https://stackoverflow.com/a/10800402
function stripSpaces(str) {
	return str.replace(/\s/g, '');
}

function listTemplates(templates) {
// <ul id="library">
	const library_list = document.getElementById("library-list");
	library_list.textContent = ''; // clear anything currently in list

	// sort templates by signature
	let signature_names = {}
	for (const name of Object.keys(templates)) {
		signature_names[templates[name].signature()] = name;
	}
	for (const signature of Object.keys(signature_names).sort()) {
		const item = document.createElement('li');
		item.innerHTML = templates[signature_names[signature]].longname;
		item.setAttribute('id', stripSpaces(signature));
		item.onclick = function() {setTemplateFromSignature(stripSpaces(signature));};
		library_list.appendChild(item);
	}
}

function setActiveTemplate(t) {
	template = t;
	const currently_highlighted = document.getElementsByClassName('library-active-template');
	for (let elem of currently_highlighted) {
		elem.classList.remove('library-active-template');
	}
	if (template) {
		const templateElem = document.getElementById(stripSpaces(template.signature()));
		templateElem.classList.add('library-active-template');
		templateElem.scrollIntoView({behavior: "smooth", block: "nearest"});
		// if ()
	}
	templateDirty();
}


// Solid knitting interface code. 

//select next template from library:
// (uses global 'library' and 'template' variables)
function nextTemplate() {
	let selected = null;
	for (const t of Object.values(library.templates)) {
		//only consider templates with larger signature than current:
		if (template !== null && t.signature() <= template.signature()) continue;
		//of these, select the smallest:
		if (selected !== null && selected.signature() < t.signature()) continue;
		console.assert(selected === null || selected.signature() != t.signature(), "All templates should have unique signatures.");
		selected = t;
	}
	setActiveTemplate(selected);
	requestRedraw();
}

//select previous template from library:
// (uses global 'library' and 'template' variables)
function prevTemplate() {
	let selected = null;
	for (const t of Object.values(library.templates)) {
		//only consider templates with smaller signature than current:
		if (template !== null && t.signature() >= template.signature()) continue;
		//of these, select the largest:
		if (selected !== null && selected.signature() > t.signature()) continue;
		console.assert(selected === null || selected.signature() != t.signature(), "All templates should have unique signatures.");
		selected = t;
	}
	setActiveTemplate(selected);
	requestRedraw();
}

//select next template from library:
// (uses global 'library' and 'template' variables)
function nextCompatibleTemplate() {
	if (CURSOR.over === null) return nextTemplate();

	const cell = CURSOR.over.cell;
	const face = CURSOR.over.face;

	let selected = null;
	for (const t of Object.values(library.templates)) {
		//only consider templates with larger signature than current:
		if (template !== null && t.signature() <= template.signature()) continue;
		//of these, select the smallest:
		if (selected !== null && selected.signature() < t.signature()) continue;
		if (checkTemplateCompatible(cell, face, t) === null) continue;
		console.assert(selected === null || selected.signature() != t.signature(), "All templates should have unique signatures.");
		selected = t;
	}
	setActiveTemplate(selected);
	requestRedraw();
}

//select previous template from library:
// (uses global 'library' and 'template' variables)
function prevCompatibleTemplate() {
	if (CURSOR.over === null) return prevTemplate();

	const cell = CURSOR.over.cell;
	const face = CURSOR.over.face;

	let selected = null;
	for (const t of Object.values(library.templates)) {
		//only consider templates with smaller signature than current:
		if (template !== null && t.signature() >= template.signature()) continue;
		//of these, select the largest:
		if (selected !== null && selected.signature() > t.signature()) continue;
		if (checkTemplateCompatible(cell, face, t) === null) continue;
		console.assert(selected === null || selected.signature() != t.signature(), "All templates should have unique signatures.");
		selected = t;
	}
	setActiveTemplate(selected);
	requestRedraw();
}

function setTemplateFromSignature(stripped_signature) {
	let selected = null;
	for (const t of Object.values(library.templates)) {
		if (stripSpaces(t.signature()) == stripped_signature) {
			selected = t;
		}
	}
	setActiveTemplate(selected);
}

// if template can be attached to face of cell, return the resulting cell
// otherwise, return null
function checkTemplateCompatible(cell, face, template, verbose = false) {
	// Cannot connect if hovered face is already connected. 
	if (cell.connections[face]) return null;

	let compat = [];
	for (let f = 0; f < template.faces.length; ++f) {
		if (sv.canConnectFaces(cell.template.faces[face], template.faces[f])) {
			compat.push(f);
		}
	}

	if (!compat.length) return null; //no compatible faces

	const tf = compat[0];

	console.assert(cell.template.faces[face].indices.length === template.faces[tf].indices.length, "Cell and connecting template face have same count of vertices.");

	//vertex lists that should connect:
	const cellVerts = [];
	const templateVerts = [];
	sv.forAlignedIndices(cell.template.faces[face], template.faces[tf], (i, ti) => {
		const cv = cell.template.faces[face].indices[i];
		const tv = template.faces[tf].indices[ti];
		cellVerts.push(cell.vertices[cv]);
		templateVerts.push(template.vertices[tv]);
	});

	const xform = gm.rigidTransform(templateVerts, cellVerts);

	const preview = sv.Cell.fromTemplate(template, xform);

	//record the fact that the connection exists:
	// preview.connections[tf] = {cell:cell, face:face};

	//see if there are other connections that might make sense:
	let centers = [];
	for (let fi = 0; fi < preview.template.faces.length; ++fi) {
		const face = template.faces[fi];
		let center = gm.vec3(0.0);
		for (let vi of face.indices) {
			center = gm.add(center, preview.vertices[vi]);
		}
		center = gm.scale(1.0 / face.indices.length, center);
		centers.push(center);
	}

	//Check all faces with compatible types for overlapping centers:
	for (let cell of body.cells) {
		for (let fi = 0; fi < cell.template.faces.length; ++fi) {
			// if (cell.connections[fi] !== null) continue;
			const face = cell.template.faces[fi];

			// if (face.type === 'x') continue;
			let center = gm.vec3(0.0);
			for (let vi of face.indices) {
				center = gm.add(center, cell.vertices[vi]);
			}
			center = gm.scale(1.0 / face.indices.length, center);

			for (let pfi = 0; pfi < preview.template.faces.length; ++pfi) {
				const dist2 = gm.dist2(center, centers[pfi]);

				if (dist2 >= 0.1 * 0.1) continue;

				// check if faces are compatible
				if (face.type ==='x' && preview.template.faces[pfi].type === 'x') {
					// this case is okay, but not a connection
					continue;
				} else if (preview.connections[pfi] != null) {
					if (verbose) console.log("preview connection already exists");
					return null;
				} else if (face.type ==='x' || preview.template.faces[pfi].type === 'x') {
					if (verbose) console.log("face.type is x");
					// return null; // commented out for increase and decrease skCAD
					continue; // added for increase and decrease skCAD
				} else if (cell.connections[fi] !== null) {
					if (verbose) console.log("cell connection already exists");
					return null;
				} else if (!sv.canConnectFaces(preview.template.faces[pfi], face)) {
					if (verbose) console.log("faces incompatible");
					return null;
				}

				// otherwise, we found a connection
				preview.connections[pfi] = {cell:cell, face:fi};
			}
		}
	}
	
	return preview;
}

// skCAD
// wrapper function of checkTemplateCompatible for unlabeled cell templates
function checkTemplateCompatibleWithUnlabeledCell(cell, face, template) {
	function tryOppositeUnlabeledCell(template) {
		let altLongname = null;
		if (template.longname === "unlabeled.right.alt") altLongname = "unlabeled.left.alt";
		else if (template.longname === "unlabeled.left.alt") altLongname = "unlabeled.right.alt";
		if (!altLongname) return null;
		const altTemplate = window.library.getTemplateByLongname(altLongname);
		return altTemplate || null;
	}

	let triedSwitch = false;
	let triedTemplate = template;
	if (checkTemplateCompatible(cell, face, template) === null) {
		const oppositeTemplate = tryOppositeUnlabeledCell(template);
		if (oppositeTemplate) {
			triedTemplate = oppositeTemplate;
			return checkTemplateCompatible(cell, face, oppositeTemplate);
		}
		return null;
	}
	return checkTemplateCompatible(cell, face, template);
}

/**
 * previewCell():
 * Returns a cell built as if by pressing 'addCell' at this very location, or 'null' if that wouldn't happen. */
function previewCell() {
	//can't add a cell if current template is no template:
	if (template === null) return null;

	if (CURSOR.grid !== null) {
		//transform that puts center of cell at cursor position on the grid:
		const xform = gm.mat4x3(
			1,0,0,
			0,1,0,
			0,0,1,
			CURSOR.grid.x, CURSOR.grid.y, 0
		);
		
		return sv.Cell.fromTemplate(template, xform);
	}

	if (CURSOR.over !== null) {
		const cell = CURSOR.over.cell;
		const face = CURSOR.over.face;
		
		return checkTemplateCompatibleWithUnlabeledCell(cell, face, template);
	}

	return null;
}
window.previewCell = previewCell; //DEBUG

/**
 * unsafeAddCell(cell, index):
 * Adds a cell to the body at a specified index in the cell list.
 * Does not perform correctness checks or store this action in the undo queue. */
function unsafeAddCell(cell, index) {
	if (cell === null) return;

	//if the cell *does* exist, hook up the other side of any connections it has:
	for (let f = 0; f < cell.connections.length; ++f) {
		const con = cell.connections[f];
		if (con === null) continue;
		console.assert(con.cell.connections[con.face] === null, "Shouldn't be over-writing connections.");
		con.cell.connections[con.face] = {cell:cell, face:f};
	}

	body.cells.splice(index, 0, cell);

	// Update UI and redraw:
	cursorDirty();
	bodyDirty();

	// skCAD
	// Update path
	determinePath();
}

/**
 * addCell (): 
 * Adds cell adjacent to selected face. */
function addCell() {
	if (CURSOR.dirty) setCursorOver();

	//is there a cell that could exist here? Ask the preview function:
	const preview = previewCell();

	//if doesn't exist, don't create anything:
	if (preview === null) return;

	const newCellIndex = body.cells.length;
	unsafeAddCell(preview, newCellIndex);

	// Record command in undo queue
	pushCommand({type: "addCell", newCellIndex: newCellIndex});

	// Check global correctness from preview cell. 
	if (!checkGlobalCellCorrectness()) console.log("Warning: There is exists a cycle in yarn directions!");
}

// skCAD
/**
 * autoSelectCell (): 
 * Automatically selects cell based on solid knitting and UI rules. */
function autoSelectCell() {
	if (CURSOR.over === null) return;

	const cell = CURSOR.over.cell;
	const face = CURSOR.over.face;
	let selected = null;

	/*--- rules ---*/
	// If hovered face is +L1(top)
	if (cell.template.faces[face].type === "+L1") {
		// If hovered cell is knit.right.alt == knit -l1 -y1 -L1 +y1 +l1 +L1
		if (cell.template.signature() === "knit -l1 -y1 -L1 +y1 +l1 +L1") {
			// select knit.right.alt
			for (const t of Object.values(library.templates)) {
				if (t.longname === "knit.right.alt") {
					selected = t;
					break;
				}
			}
		}
	}
	
	// check compatibility of selxected template and redraw
	if (selected) {
		const compatible = checkTemplateCompatible(cell, face, selected);
		if (compatible !== null) {
			setActiveTemplate(selected);
			requestRedraw();
		}
	}
}

// skCAD
/**
 * autoReselectCell (): 
 * Automatically reselects cell based on solid knitting and UI rules. */
function autoReselectCell() {
	for (let i = 0; i < body.cells.length; ++i) {
		const cell = body.cells[i];

		// Get the face index of the -L face
		let targetFaceIndex = -1;
		for (let fi = 0; fi < cell.template.faces.length; ++fi) {
			if (cell.template.faces[fi].type === "-L1") {
				targetFaceIndex = fi;
				break;
			}
		}

		// Skip if the -L face does not exist
		if (targetFaceIndex === -1) continue;

		// Skip if already connected
		if (cell.connections[targetFaceIndex] !== null) continue;

		// Find a new template
		let newTemplate = null;
		for (const t of Object.values(library.templates)) {
			if (t.longname === "knit.over-empty.right.alt") {
				newTemplate = t;
				break;
			}
		}

		if (!newTemplate) {
			console.error("Template 'knit.over-empty.right.alt' not found");
			continue;
		}

		// Save the connection information of the old cell
		const oldConnections = cell.connections;

		// Create a new cell (using the same transformation matrix)
		const newCell = sv.Cell.fromTemplate(newTemplate, cell.xform);

		// Transfer connections to newCell (only if face type and index count match)
		for (let fi = 0; fi < newCell.template.faces.length; ++fi) {
			const newFace = newCell.template.faces[fi];
			for (let oldFi = 0; oldFi < cell.template.faces.length; ++oldFi) {
				const oldFace = cell.template.faces[oldFi];
				if (newFace.type === oldFace.type &&
					newFace.indices.length === oldFace.indices.length &&
					oldConnections[oldFi] !== null) {

					newCell.connections[fi] = oldConnections[oldFi];
					const other = oldConnections[oldFi];
					// Also update the connection on the other side
					other.cell.connections[other.face] = {cell: newCell, face: fi};
				}
			}
		}

		// Replace the cell
		body.cells[i] = newCell;
	}
	bodyDirty();
	requestRedraw();
}

function findOppositeYarnDirectionTemplate(template) {
	const oppName = template.longname.replace("left", "LEFT").replace("right", "left").replace("LEFT", "right");
	for (const t of Object.values(library.templates)) {
		if (t.longname === oppName) return t;
	}
	return null;
}

/**
 * extrudeSelected (): 
 * Adds a properly-transformed copy of selected cell adjacent to selected face. */
function extrudeSelected() {
	if (CURSOR.dirty) setCursorOver();
	if (CURSOR.over == null) return;

	const newCellIndex = body.cells.length;

	const result = unsafeExtrudeFace(CURSOR.over.cell, CURSOR.over.face);
	if (result != null) {
		// If successful, record command in undo queue. Store old cursor since extrusion can move cursor
		const oldCursor = storeCursor(CURSOR);
		pushCommand({type: "addCell", newCellIndex: newCellIndex, oldCursor: oldCursor});

		if (CURSOR.frozen) {
			unsafeSelectFace(result.cell, result.face);
			requestRedraw();
		}
	}
	return result;
}

/**
 * unsafeExtrudeFace(): 
 * Adds a properly-transformed copy of cell adjacent to face. Returns the new cell and its face of the same type if one was created, null otherwise.
 * Does not store action in undo queue.*/
function unsafeExtrudeFace(cell, face) {
	if (cell.template.name != "knit") {
		console.error("Currently only knits can be extruded");
		return null;
	}

	// console.log(face, cell.template.faces);
	const faceType = cell.template.faces[face].type;

	if (faceType.length < 2) {
		return; // we can't attach to this face
	}

	let preview = null, previewFace=null;
	if (faceType[1] === "y") {
		// yarnwise-connected: keep same direction
		preview = checkTemplateCompatible(cell, face, cell.template);
		if (preview == null) return null;
	} else if (faceType[1] === "l") {
		// neighboring rows: we should flip direction
		preview = checkTemplateCompatible(cell, face, findOppositeYarnDirectionTemplate(cell.template));
		if (preview == null) return null;
		previewFace = preview.template.faceFromType(faceType);
	} else if (faceType[1] === "L") {
		// neighboring layers: confusingly, we need to flip direction if we're "same"
		if (cell.template.longname.endsWith("same")) {
			preview = checkTemplateCompatible(cell, face, findOppositeYarnDirectionTemplate(cell.template));
			if (preview == null) return null;
			previewFace = preview.template.faceFromType(faceType);
		} else {
			preview = checkTemplateCompatible(cell, face, cell.template);
			previewFace = face;
		}
	}

	//if doesn't exist, don't create anything:
	if (preview === null) return;

	const newCellIndex = body.cells.length;
	unsafeAddCell(preview, newCellIndex);

	// Check global correctness from preview cell. 
	if (!checkGlobalCellCorrectness()) console.log("Warning: There is exists a cycle in yarn directions!");
	return {cell: preview, face: previewFace};
}

/**
 * extrudeContiguous (): 
 * Attempts to extrude each face connected to the hovered face via faces of the same signature whose normal points in the same direction */
function extrudeContiguous() {
	if (CURSOR.dirty) setCursorOver();
	if (CURSOR.over == null) return;

	const cell = CURSOR.over.cell;
	const face = CURSOR.over.face;
	const faceType = cell.template.faces[face].type;
	if (faceType.length < 2) return;

	function faceNormal(cell, face) {
		const fVerts = cell.template.faces[face].indices;
		return gm.normalize(gm.cross(gm.sub(cell.vertices[fVerts[1]], cell.vertices[fVerts[0]]), gm.sub(cell.vertices[fVerts[2]], cell.vertices[fVerts[0]])));
	}

	const sig = faceType[1];
	const n = faceNormal(cell, face);

	const regionFaces = [];
	const cellQueue = [cell];
	const visited = new Set([cell]);

	while (cellQueue.length != 0) {
		const currCell = cellQueue.pop();
		let found = false;
		for (let iF = 0; iF < currCell.template.faces.length; ++iF) {
			if (currCell.connections[iF] || currCell.template.faces[iF].type.length < 2) continue;

			if (currCell.template.faces[iF].type[1] === sig && gm.dot(n, faceNormal(currCell, iF)) > 0.9) {
				regionFaces.push({cell: currCell, face: iF});
				found = true;
			}
		}
		if (found) {
			for (let iF = 0; iF < currCell.template.faces.length; ++iF) {
				if (currCell.connections[iF] && !visited.has(currCell.connections[iF].cell)) {
					cellQueue.push(currCell.connections[iF].cell);
					visited.add(currCell.connections[iF].cell);
				}
			}
		}
	}

	// Store old cursor since extrusion can move cursor
	const oldCursor = storeCursor(CURSOR);
	const newCellIndices = [];
	for (let iF=0; iF<regionFaces.length; iF++) {
		const newCellIndex = body.cells.length;
		const createdFace = unsafeExtrudeFace(regionFaces[iF].cell, regionFaces[iF].face);
		if (createdFace != null) newCellIndices.push(newCellIndex);
		if (iF === 0 && CURSOR.frozen) {
			unsafeSelectFace(createdFace.cell, createdFace.face);
		}
	}
	pushCommand({type: "addMultipleCells", newCellIndices: newCellIndices, oldCursor: oldCursor});
}

/**
 * checkGlobalCellCorrectness():
 * Topological sort to check correctness using BFS using Kahn's accross entire implementation.
 * Overall complexity of O(|E| + |V).
 * Print results to #status-text div */
function checkGlobalCellCorrectness() {
	// Dictionary of visited cells {cell, visit #}
	let inDegrees = new Map();

	// bodyLen == Expected count of elements in topological sort. (based on the indegree value) 
	let bodyLen = body.cells.length;

	// Initialize all cells in body into dictionary.
	for (let i = 0; i < bodyLen; i++) inDegrees.set(body.cells[i], 0);

	// Iterate accross all cell connections.
	for (let i = 0; i < bodyLen; i++){
		let currCell = body.cells[i]; /* cell */
		let currCellCon = currCell.connections;
		let currCellConLen = currCellCon.length;

		// Calculate indegrees for all adjacent/connected cells.
		for (let v = 0; v < currCellConLen; v++){
			let currFace = v; /*face*/
			let adjCellCon = currCellCon[currFace]

			if (adjCellCon != null){
				let adjCellFace = adjCellCon.face /* toFace */
				let adjCell = adjCellCon.cell /* toCell */
				
				// Assert that only yarn directions are taken into account. 
				// Only one direction is taken into account, in this case were 
				// assume the current cell (-y) connects with adjacent cell 
				// (+y) to avoid double counting. 
				// I.e. both (+y) -> (-y) and (-y) -> (+y). 
				if (sv.canConnectFaces(currCell.template.faces[currFace], adjCell.template.faces[adjCellFace]) &&
					(currCell.template.faces[currFace].type[1] == 'y') &&
					(currCell.template.faces[currFace].type[0] == '-')){
					// Increment inDegree calculation.
					let val = inDegrees.get(adjCell);
					inDegrees.set(adjCell, ++val);
				}
			}
		}
	}
	
	let count = 0; 

	// Queue of cells to visit, based on cells with inDegree 0.
	let toVisit =  body.cells.filter(cell => (inDegrees.get(cell) == 0));

	// Array to keep track of topological order. 
	let topOrder = [];

	// Topological ordering of vertices. 
	while (toVisit.length != 0){
		// Shift topmost element: 
		let currCell = toVisit.shift(); /* face */
		topOrder.push(currCell);

		let currCellCon = currCell.connections;
		let currCellConLen = currCellCon.length;

		// Calculate indegrees for all adjacent/connected cells.
		for (let v = 0; v < currCellConLen; v++){
			let currFace = v; /*face*/
			let adjCellCon = currCellCon[currFace]

			if (adjCellCon != null){
				let adjCellFace = adjCellCon.face /* toFace */
				let adjCell = adjCellCon.cell /* toCell */
				
				if (sv.canConnectFaces(currCell.template.faces[currFace], adjCell.template.faces[adjCellFace]) &&
					(currCell.template.faces[currFace].type[1] == 'y') &&
					(currCell.template.faces[currFace].type[0] == '-')){
					let val = inDegrees.get(adjCell); 
					if (--val == 0) toVisit.push(adjCell);
				}
			}
		}
		count++;
	}

	let cycleFree = (count == bodyLen);

	if (cycleFree) {
		document.getElementById("cycle-text").innerHTML = "No cycles detected in yarn directions.";
	} else {
		document.getElementById("cycle-text").innerHTML = "Warning: There is exists a cycle in yarn directions!";
	}
	return cycleFree;
}

/**
 * allocateSpots(x0=1, y0=4)
 * Schedules a needle, frontHolder, backHolder, layer, direction, and yarnID for each cell, storing these in cell.schedulingData.
 * Currently computes locations for knit, next-row, yarn-next-layer, loop-next-layer, cast-on, bind-off. */
function allocateSpots(x0=1, y0=4) {
	// follow yarn through body
	function getYarnExitFace(cell) {
		for (let iF=0; iF<cell.template.faces.length; ++iF) {
			if (cell.template.faces[iF].type.startsWith("+y")) return iF;
		}
		return null;
	}

	// set default schedulingData and look for yarn-in to start
	let currCell = null;
	let nYarnIn = 0, nYarnOut = 0;
	for (let cellID = 0; cellID < body.cells.length; ++cellID) {
		if (body.cells[cellID].schedulingData == null) {
			body.cells[cellID].schedulingData = {
				direction : null,
				waleDirection : null,
				bed : null,
				embedding : null,
				HFxy : null,
				HBxy : null,
				Nx : null, 
				D : null,
				CS : null,
				layer : null,
				layerOffset : null,
				priority : null,
				cellID : cellID
			};
		} else {
			body.cells[cellID].schedulingData.embedding = null; // always recompute embedding 
			body.cells[cellID].schedulingData.cellID = cellID; // always update cellID
		}
		if (body.cells[cellID].template.name === "yarn-in") {
			currCell = body.cells[cellID];
			nYarnIn++;
		} else if (body.cells[cellID].template.name === "yarn-out") {
			nYarnOut++;
		}
	}
	if (currCell == null) {
		console.error("spot allocation failed: no yarn-in cell found");
		return;
	}
	if (nYarnIn != 1 || nYarnOut != 1) {
		document.getElementById("yarn-count-text").innerHTML = "Error: There are " + nYarnIn + " yarn-in blocks and " + nYarnOut + " yarn out blocks, when there should only be one of each";
		return;
	} else {
		document.getElementById("yarn-count-text").innerHTML = "";
	}

	let exitFace = getYarnExitFace(currCell);
	let currDirection = (exitFace === 2) ? -1  
	                  : (exitFace === 4) ? 1  
	                  : null;
	if (currDirection == null) {
		console.error("spot allocation failed: unrecognized yarn-in signature ", currCell.signature());
		return;
	}

	let currBed = 1; // somewhat confusingly, bed is the stitch that the bed gets made on, which is opposite to the bed used for the needle
	let currWaleDirection = 1; 
	currCell.schedulingData.embedding = gm.vec3(0, 0, 0);

	//== find directions & beds for all stitches and embeddings for knit stitches
	// (an embedding is an abstract set of 3d coordinates that we'll use later to get needle/holder positions)
	let xMax=-10, yMax=-10, xMin=10, yMin=10, zMin=10;
	while (currCell != null) {
		currCell.schedulingData.direction = (currDirection > 0) ? "+" : "-";
		currCell.schedulingData.waleDirection = (currWaleDirection > 0) ? "+" : "-";
		currCell.schedulingData.bed = (currBed > 0) ? "f" : "b";
		if (currCell.template.name.startsWith("yarn-next-row")) {
			currDirection *= -1;
		} else if (currCell.template.name.startsWith("yarn-next-layer")) {
			currWaleDirection *= -1; 
			currDirection *= -1;
			currBed *= -1;
		}

		//== locate yarn out and propagate embedding. Leave the embedding of yarn-next-row/yarn-next-layer/drop blocks to be filled in later
		let exitFace = null;
		for (let iF=0; iF<currCell.template.faces.length; ++iF) {
			const faceType = currCell.template.faces[iF].type;

			if (faceType.startsWith("+y")) exitFace = iF;

			if (currCell.connections[iF] == null || currCell.template.name.startsWith("yarn-next") || currCell.template.name.startsWith("loop-next")) continue;
			const connection = currCell.connections[iF].cell;
			if (connection.template.name.startsWith("yarn-next") || connection.template.name.startsWith("loop-next")) continue;

			let offset = null;
			if (faceType.startsWith("+y")) {
				offset = gm.vec3(currDirection, 0, 0);
			} else if (faceType.startsWith("-y")) {
				offset = gm.vec3(-currDirection, 0, 0);
			} else if (faceType.startsWith("+L")) {
				offset = gm.vec3(0, 0, 1);
			} else if (faceType.startsWith("-L")) {
				offset = gm.vec3(0, 0, -1);
			} else if (faceType.startsWith("+l")) {
				offset = gm.vec3(0, currWaleDirection, 0);
				// special case for cast-on which shares location
				if (currCell.template.name.startsWith("cast-on")) offset = gm.vec3(0, 0, 0);
			} else if (faceType.startsWith("-l")) {
				offset = gm.vec3(0, -currWaleDirection, 0);
				// special case for bind-off which shares location
				if (currCell.template.name.startsWith("bind-off")) offset = gm.vec3(0, 0, 0);
			} else {
				console.log("cannot propagate face type ", faceType);
				continue;
			}

			const connectionEmbedding = gm.add(currCell.schedulingData.embedding, offset);
			if (connection.template.name === "drop") {
				// drop simply copies scheduling data from its neighbor
				connection.schedulingData.direction     = currCell.schedulingData.direction;
				connection.schedulingData.waleDirection = currCell.schedulingData.waleDirection;
				connection.schedulingData.bed           = currCell.schedulingData.bed;
				connection.schedulingData.embedding     = gm.vec3(currCell.schedulingData.embedding);
			} else if (connection.schedulingData.embedding == null) {
				connection.schedulingData.embedding = connectionEmbedding;
				const name = connection.template.name;
				if (!(name.startsWith("yarn-out") || name.startsWith("cast-on") || name.startsWith("bind-off"))) { // ignore cast-on, bind-off, yarn-out when computing bounds
					xMax = Math.max(xMax, connectionEmbedding[0]);
					yMax = Math.max(yMax, connectionEmbedding[1]);
					xMin = Math.min(xMin, connectionEmbedding[0]);
					yMin = Math.min(yMin, connectionEmbedding[1]);
					zMin = Math.min(yMin, connectionEmbedding[2]);
				}
			} else {
				// don't check yarn-next-row/yarn-next-layer or cast-on/bind-off blocks for now since they have special rules
				if (connection.template.name.startsWith("yarn-next")
				   || connection.template.name.startsWith("loop-next")
				   || connection.template.name.startsWith("cast-on")  || currCell.template.name.startsWith("cast-on")
				   || connection.template.name.startsWith("bind-off") || currCell.template.name.startsWith("bind-of")) continue;

				if ((Math.abs(connectionEmbedding[0] - connection.schedulingData.embedding[0]) > 0.01)
				 || (Math.abs(connectionEmbedding[1] - connection.schedulingData.embedding[1]) > 0.01)
				 || (Math.abs(connectionEmbedding[2] - connection.schedulingData.embedding[2]) > 0.01)) {
					console.error("mismatched neighbors ", currCell, connection);
				}
			}
		}

		if (exitFace != null) {
			currCell = currCell.connections[exitFace].cell;
		} else {
			currCell = null;
		}
	}

	// shift embedding to start at the origin and assign embeddings for loop-next-layer blocks
	for (let cell of body.cells) {
		// use default priority and layer offset if nothing else is specified
		if (cell.template.name.startsWith("loop-next-layer")) {
			if (cell.schedulingData.priority == null) cell.schedulingData.priority = 1;
			if (cell.schedulingData.layerOffset == null) cell.schedulingData.layerOffset = 0;
		} else if (cell.template.name.startsWith("drop")) { // also set for adjacent drops below
			if (cell.schedulingData.priority == null) cell.schedulingData.priority = 2;
			if (cell.schedulingData.layerOffset == null) cell.schedulingData.layerOffset = 1;
		} else if (cell.template.name.startsWith("yarn-next-layer")) {
			if (cell.schedulingData.priority == null) cell.schedulingData.priority = 3;
			if (cell.schedulingData.layerOffset == null) cell.schedulingData.layerOffset = 0;
		} else {
			if (cell.schedulingData.priority == null) cell.schedulingData.priority = 0;
			if (cell.schedulingData.layerOffset == null) cell.schedulingData.layerOffset = 0;
		}

		if (cell.schedulingData.embedding) {
			cell.schedulingData.embedding[0] -= xMin;
			cell.schedulingData.embedding[1] -= yMin;
			cell.schedulingData.embedding[2] -= zMin;
		} else if (cell.template.name.startsWith("loop-next-layer")) {
			// make sure to look at loop in to specify correct holder for xfer
			for (let iF=0; iF<cell.template.faces.length; iF++){
				if (!cell.connections[iF]) continue;
				if (cell.template.faces[iF].type.startsWith("-l")) {
					// loop in
					const bed = cell.connections[iF].cell.schedulingData.bed
					cell.schedulingData.bed = bed;
					cell.schedulingData.embedding = gm.copyVec3(cell.connections[iF].cell.schedulingData.embedding);
					if (bed === "f") {
						cell.schedulingData.embedding[1] += 1; // xfer to front -> bump up y coord
					} else {
						cell.schedulingData.embedding[1] -= 1; // xfer to back -> bump down y coord
					}
					// move z coord between layers
					cell.schedulingData.embedding[2] += 0.5;
				}
			}
		}
	}
	xMax -= xMin; yMax -= yMin; // shift maxima
	xMin = 0; yMin = 0; zMin = 0; // shift minima

	function holderPositions(x, y) {
		return {f: "hf" + (x+x0) + "," + (y0+y), b: "hb" + (x+x0) + "," + (y0+yMax-y)};
	}

	for (let cell of body.cells) {
		if (cell.schedulingData.embedding != null) {
			let x = cell.schedulingData.embedding[0], y = cell.schedulingData.embedding[1], z = cell.schedulingData.embedding[2];
			// somewhat confusingly, bed is the stitch that the bed gets made on, which is opposite to the bed used for the needle
			// except for drops, which use the needle on the bed which the stitch is stored on
			let needleBed = (cell.schedulingData.bed === "f") ? "b" : "f";
			if (cell.template.name === "drop") {
				needleBed = cell.schedulingData.bed;
			}
			const holders = holderPositions(x, y);
			cell.schedulingData.HFxy = holders.f;
			cell.schedulingData.HBxy = holders.b;
			cell.schedulingData.Nx = needleBed + (x+x0); 
			cell.schedulingData.Nopx = cell.schedulingData.bed + (x+x0); 
			cell.schedulingData.D = cell.schedulingData.direction;
			cell.schedulingData.CS = [1];

			// not currently used
			cell.schedulingData.layer = z;
		}

	}
}

/**
 * exportSolidKnitout(body):
 * Returns an ordered list of code fragments from the cells in body.
 * Code fragments are represented as objects of the form { id, instructions }
 * Consecutive fragments with the same id should later have their instructions interleaved
 * For example, if we have fragments { fragA, [xfer0, knit0] }, { fragA, [xfer1, knit1] }, { fragB, [xfer2, knit2, drop2] },
 * then we should eventually emit code:
 *     xfer0
 *     xfer1
 *     knit0
 *     knit1
 *     xfer2
 *     knit2
 *     drop2
 * This reordering is done by the groupPasses function in code/sk.mjs */
function exportSolidKnitout(body) {

	// Solid knitout functions for parsing. 
	// Subroutines for string processing. 
	function skPause(str) {
		return { "id": "pause", "instructions": ["pause " + str] };
	}
	// For things such as carrier info or add layer 
	function skComment(str) {
		return { "id": "comment", "instructions": ["; " + str] };
	}

	// Use the scheduling data associated with `cell` to fill in the placeholder values used in instruction string `str`.
	// Comment string is appended afterwards to ensure that it is not modified.
	// If `str` is a `pause` command, then the comment is dropped since `pause` does not respect comments
	function fillInStitchLocation(str, cell, comment) {
		let tmp = str;
		if (cell != null && cell.schedulingData != null) {
			if (cell.schedulingData.bed == 'b'){
				tmp = tmp.replaceAll('[Hxy]', cell.schedulingData.HBxy);
				tmp = tmp.replaceAll('[Hopxy]', cell.schedulingData.HFxy);
			} else{
				tmp = tmp.replaceAll('[Hxy]', cell.schedulingData.HFxy);
				tmp = tmp.replaceAll('[Hopxy]', cell.schedulingData.HBxy);
			}

			tmp = tmp.replaceAll('[Nx]', cell.schedulingData.Nx);
			tmp = tmp.replaceAll('[Nopx]', cell.schedulingData.Nopx);
			tmp = tmp.replaceAll('[CS]', cell.schedulingData.CS);
			tmp = tmp.replaceAll('[HBxy]', cell.schedulingData.HBxy);
			tmp = tmp.replaceAll('[HFxy]', cell.schedulingData.HFxy);
			tmp = tmp.replaceAll('[f/b]', cell.schedulingData.bed);
			tmp = tmp.replaceAll('[D]', cell.schedulingData.D);
		} else {
			console.log("No scheduling data available!")
		}
		if (tmp.includes("[Hxy]")){
			console.log(currCell.schedulingData);
		}

		// skip comment if instruction include pause (which would eat the comments)
		if (comment != null && !tmp.includes("pause")) {
			tmp += ' ; ' + comment;
		}
		return tmp;
	}

	// Create a code fragment from the input instructions
	function skSchedule(instructions, cell, comment) {
		// by default, give every block a unique id so that instructions are not merged
		let id = cell.template.name + "." + cell.schedulingData.cellID;

		// if the block is in the following list of types which should have their instructions merged into passes,
		// give it a standard id which will by shared by all other blocks of this type in this row
		let instructionGroups = ["knit", "drop", "cast-on", "loop-next-layer", "bind-off"];
		for (const instructionName of instructionGroups) {
			if (cell.template.name.startsWith(instructionName)) {
				id =  instructionName + "." + cell.schedulingData.embedding[1] + "." + cell.schedulingData.embedding[2];
				break;
			}
		}

		// HACK: special treatment of blocks adjacent to a cast-on block, which are themselves really part of the cast-on
		// These should probably be treated as separate blocks
		let isCastOnKnit = false;
		if (cell.template.name.startsWith("knit")) {
			// check to see if any neighboring block is a cast-on
			for (let currFace = 0; currFace < cell.connections.length; currFace++){
				if (cell.connections[currFace]!= null){
					if (cell.connections[currFace].cell.template.name.startsWith("cast-on")) {
						isCastOnKnit = true;
						break;
					}
				}
			}
		}

		let concreteInstructions = [];
		for (const instructionTemplate of cell.template.machine) {
			// skip xfers for cast on knit blocks
			if (isCastOnKnit && instructionTemplate.startsWith("xfer")) continue;

			concreteInstructions.push(fillInStitchLocation(instructionTemplate, cell, comment));
		}
		return {"id": id, "instructions": concreteInstructions };
	}
	const cells = body.cells;

	// Identify starting block (i.e. beginning at block type containing 'yarn-in')
	let start = cells.find(cell => (cell != null) && (cell.template.name == "yarn-in"));
	const fragments = [];
	fragments.push(skComment("Autogenerated Solid Knitout code block."), skComment("Carrier 1"));

	// toVisit is an array of queues, each containing cells of a specific priority.
	// Depending on the type of block, certain blocks will be enqued in a specific order for grouping purposes. 
	// toVisit[0] -> P1 (almost everything)
	// toVisit[1] -> P2 (loop-next-layer)
	// toVisit[2] -> P3 (drop) [stored as a stack rather than a queue]
	// toVisit[3] -> P4 (yarn-next-layer)
	let toVisit = [[start], [], [], []]
	let layerOffsetCells = [[], [], [], []] // priority queue of cells to be scheduled in later layers based on their `layerOffset` values
	let visited = []

	let iRow = 0;
	let iLayer = 0;

	// init data for topological sort
	for (let cell of cells) {
		cell.topoSort = {};
		cell.topoSort.inFaces = 0;
		for (let iF = 0; iF < template.faces.length; ++iF) {
			if (cell.template.faces[iF].type.startsWith("-")) cell.topoSort.inFaces++;
		}
	}

	// console.log(start);
	while (toVisit[0].length != 0 || toVisit[1].length != 0 || toVisit[2].length != 0 || toVisit[3].length != 0) {
		let currCell = null;
		if (toVisit[0].length != 0) {
			currCell = toVisit[0].shift();
		} else if (toVisit[1].length != 0) {
			currCell = toVisit[1].shift();
		} else if (toVisit[2].length != 0) {
			currCell = toVisit[2].shift();
		} else if (toVisit[3].length != 0) {
			currCell = toVisit[3].shift();
		}

		// annotate instructions with cell ID,
		let comment = 'cell ' + currCell.schedulingData.cellID;
		fragments.push(skSchedule(currCell.template.machine, currCell, comment));	

		// Processing of strings and related information goes here. 

		if (currCell.template.name.startsWith("yarn-next-row")) {
			iRow++;
			fragments.push(skComment("row " + iRow));
		} else if (currCell.template.name.startsWith("yarn-next-layer")) {
			iLayer++;
			iRow = 0;
			fragments.push(skComment("============================="));
			fragments.push(skComment("         Layer " + iLayer));
			fragments.push(skComment("============================="));
			fragments.push(skComment("row " + iRow));

			// Now that we've gone up a layer, check if it's time to schedule the cells in the layerOffsetCells queue
			// All layer offsets are decremented, and any cells with zero offset are scheduled for the current layer
			for (let priority = 0; priority < layerOffsetCells.length; priority++) {
				for (let i = 0; i < layerOffsetCells[priority].length; i++) {
					layerOffsetCells[priority][i].offset -= 1;
					if (layerOffsetCells[priority][i].offset === 0) {
						// console.log("Scheduling ", layerOffsetCells[priority][i].cell.schedulingData.cellID)
						toVisit[priority].push(layerOffsetCells[priority][i].cell);
					} else {
						// console.log("Deferring ", layerOffsetCells[priority][i].offset, layerOffsetCells[priority][i].cell.schedulingData.cellID)
					}
				}
				layerOffsetCells[priority] = layerOffsetCells[priority].filter((e) => e.offset > 0);
			}
		} else if (currCell.template.name.startsWith("yarn-in")) {
			iLayer = 0;
			iRow = -1;
			fragments.push(skComment("============================="));
			fragments.push(skComment("         Layer " + iLayer));
			fragments.push(skComment("============================="));
			fragments.push(skComment("row " + iRow));
		}

		// face
		let currCellCon = currCell.connections;
		let currCellConLen = currCellCon.length; 
		for (let currFace = 0; currFace < currCellConLen; currFace++){
			if (currCellCon[currFace]!= null){
				let adjCell = currCellCon[currFace].cell;
				let adjCellFace = currCellCon[currFace].face;
				//if (sv.canConnectFaces(currCell.template.faces[currFace], adjCell.template.faces[adjCellFace])){
				if (!visited.includes(adjCell) && adjCell.template.faces[adjCellFace].type.startsWith("-")){
					adjCell.topoSort.inFaces--; // record that we've satisfied a depencency
					if (adjCell.topoSort.inFaces > 0) continue; // don't proceed if there are unfulfilled dependencies

					if (adjCell.schedulingData.layerOffset === 0) {
						toVisit[adjCell.schedulingData.priority].push(adjCell);
					} else {
						// console.log("Saving ", adjCell.schedulingData.cellID, " at offset ", adjCell.schedulingData.layerOffset);
						layerOffsetCells[adjCell.schedulingData.priority].push({"offset": adjCell.schedulingData.layerOffset, "cell": adjCell});
					}
					visited.push(currCell);
				}
			}
		}
		if (currCell.template.name == "yarn-out") {
			toVisit == [[],[], [], []]; 
		}
	}

	// clean up data for topological sort
	for (let cell of cells) {
		delete cell.topoSort;
	}

	fragments.push(skPause("knitting complete, please remove object from machine."));  // Assuming theres no dropping mechanism?

	return fragments;
}

/**
 * displayHoveredBlockInfo(over)
 * display the scheduling data associated with block `over` in the `hovered-block-info` area on screen. */
function displayHoveredBlockInfo(over) {
	const infoArea = document.getElementById("hovered-block-info");
	infoArea.innerHTML = "";

	let posString, embString, id, ports, longname, schedulingData;
	if (over != null) {
		id = over.cellID;
		ports = over.cell.template.signature().substr(over.cell.template.name.length + 1);
		longname = over.cell.template.longname;
		const pos = gm.xformTranslation(over.cell.xform); 
		posString = "( " + pos[0].toFixed(2) + ", " + pos[1].toFixed(2) + ", " + pos[2].toFixed(2) + " )";
		schedulingData = over.cell.schedulingData ? over.cell.schedulingData : {};


		if (over.cell.schedulingData && over.cell.schedulingData.embedding) {
			const emb = over.cell.schedulingData.embedding;
			embString = "( " + emb[0].toFixed(2) + ", " + emb[1].toFixed(2) + ", " + emb[2].toFixed(2) + " )";	
		}
	} else {
		id = null;
		ports = null;
		longname = null;
		posString = null;
		schedulingData = {};
	}

	const displayData = function(name, value, variableName) {
		const nameElem = document.createElement('label');
		nameElem.innerHTML = name;
		nameElem.classList.add("field-name");
		nameElem.for = "input-" + name;
		infoArea.appendChild(nameElem);
		const valueElem = document.createElement('div');
		valueElem.classList.add("field-value");
		if (variableName == null) {
			valueElem.innerHTML = value == null ? "&nbsp;" : value; // print space to set line height
		} else {
			const textInput = document.createElement('input');
			textInput.type = "text";
			textInput.id = "input-"+name;
			textInput.name = name;
			textInput.value = value == null ? "" : value; // print space to set line height
			if (over == null) {
				textInput.disabled = true;
			} else {
				textInput.onchange = function() {
					pushCommand({type: "editSchedulingData", cell: over.cell, field: variableName, oldValue: over.cell.schedulingData[variableName], newValue: textInput.value});
					over.cell.schedulingData[variableName] = textInput.value;
				};
			}
			valueElem.appendChild(textInput);
		}
		infoArea.appendChild(valueElem);
	};
	
	displayData("ID", id);
	displayData("Long Name", longname);
	displayData("Ports", ports);
	displayData("Position", posString);
	displayData("Embedding", embString);
	displayData("Bed", schedulingData.bed, "bed");
	displayData("Nx", schedulingData.Nx, "Nx");
	displayData("HFxy", schedulingData.HFxy, "HFxy");
	displayData("HBxy", schedulingData.HBxy, "HBxy");
	displayData("D", schedulingData.D, "D");
	displayData("CS", schedulingData.CS, "CS");
	displayData("Layer", schedulingData.layer, "layer");
	displayData("Layer Offset", schedulingData.layerOffset, "layerOffset");
	displayData("Block Priority", schedulingData.priority, "priority");
}

/**
 * unsafeDeleteCell(index)
 * Adds a cell to the body at a specified index in the cell list.
 * Does not perform correctness checks or store this action in the undo queue. */
function unsafeDeleteCell(index) {
	const cellConnections = body.cells[index].connections;

	// Update all connections referencing current cell.
	for (let i = 0; i < cellConnections.length; i++) {
		if(cellConnections[i] != null){
			const currCell = cellConnections[i].cell;
			const currFace = cellConnections[i].face;
			currCell.connections[currFace] = null;
		}
	}

	// Remove current cell from body. 
	body.cells.splice(index, 1);

	// Update UI and redraw:
	cursorDirty();
	bodyDirty();

	// skCAD
	// Update path
	determinePath();
}

/**
 * deleteCell (): 
 * Deletes currently selected cell, regardless of face type. 
 * Consider: When cell is selected to delete a box, instead of highlighting
 * selected face, we should highlight selected cell. */
function deleteCell() {
	if (CURSOR.dirty) setCursorOver();
	if (!CURSOR.over) return;

	const cell = CURSOR.over.cell;
	const cellIndex =  body.cells.indexOf(cell);

	unsafeDeleteCell(cellIndex);

	// Record command in undo queue
	pushCommand({type: "deleteCell", cell: cell, cellIndex: cellIndex});

	// Check global correctness from preview cell. 
	if (!checkGlobalCellCorrectness()) console.log("Warning: There is exists a cycle in yarn directions!");
}

/**
 * startConnectFace()
 * Start connecting current face
 */
function startConnectFace() {
	if (ACTION !== null) return;
	if (CURSOR.dirty) setCursorOver();
	if (!CURSOR.over) return;
	const oldCursor = storeCursor(CURSOR);
	const cell = CURSOR.over.cell;
	const face = CURSOR.over.face;
	delete CURSOR.frozen;

	//is face already connected?
	const oldConnection = cell.connections[face];

	function clearConnection() {
		if (cell.connections[face] !== null) {
			const toCell = cell.connections[face].cell;
			const toFace = cell.connections[face].face;
			console.assert(toCell.connections[toFace] !== null
			 && toCell.connections[toFace].cell === cell
			 && toCell.connections[toFace].face === face, "connections should be reflexive");
			toCell.connections[toFace] = null;
			cell.connections[face] = null;
			cellDirty(cell);
		}
	}

	clearConnection();

	function setConnection() {
		if (!setConnection.pending) return; //HACK: allow cancelling past end-of-action
		setConnection.pending = false;

		clearConnection();
		if (CURSOR.dirty) setCursorOver();
		if (!CURSOR.over) return;
		const toCell = CURSOR.over.cell;
		if (toCell === cell) return; //can't self-connect
		const toFace = CURSOR.over.face;
		if (toCell.connections[toFace]) return; //can't double-connect

		if (!sv.canConnectFaces(cell.template.faces[face], toCell.template.faces[toFace])) return;


		//make the connection:
		cell.connections[face] = {cell:toCell, face:toFace};
		toCell.connections[toFace] = {cell:cell, face:face};

		if (!checkGlobalCellCorrectness()) console.log("Warning: There is exists a cycle in yarn directions!");

		cellDirty(cell);
	}

	function cancelConnect() {
		console.log("Cancelling connect.");
		setConnection.pending = false;
		cell.connections[face] = oldConnection;
		if (oldConnection) {
			oldConnection.cell.connections[oldConnection.face] = {cell:cell, face:face};
		}
		cellDirty(cell);
		ACTION = null;
	}

	console.log("Starting connect.");

	ACTION = {
		type: "Connect",
		mousedown:(evt,mouse) => {
			if (evt.button === 0) {
				startCameraMove();
			} else if (evt.button === 2) {
				cancelConnect();
			}
		},
		//nothing: mouseup:(evt,mouse) => { },
		mousemove:(evt,mouse) => {
			if (!setConnection.pending) {
				setConnection.pending = true;
				window.requestAnimationFrame( setConnection );
			}
		},
		keydown:(evt) => {
			if (evt.code === 'KeyC') {
				console.log("Confirming connect.");
				setConnection.pending = false;
				ACTION = null;
				pushCommand({type: "confirmConnect", cellIndex: body.cells.indexOf(cell), face: face, oldConnection: oldConnection});
			} else if (evt.code === 'Escape') {
				cancelConnect();
				restoreCursor(oldCursor);
			}
		},
	};


}


/**
 * startGrabCell()
 * Grab (start moving) current cell.
 */
function startGrabCell() {
	if (ACTION !== null) return;

	if (CURSOR.dirty) setCursorOver();

	if (!CURSOR.over) return;


	const cell = CURSOR.over.cell;
	const startXform = cell.xform;
	const startVertices = [];
	let center = gm.vec3(0);
	for (const v of cell.vertices) {
		startVertices.push(gm.vec3(v));
		center = gm.add(center, v);
	}
	center = gm.scale(1 / cell.vertices.length, center);

	const right = camera.computeRight();
	const up = camera.computeUp();
	const out = camera.computeOut();

	function mousePt() {
		const ray = mouseRay();
		const offset = gm.dot(gm.sub(ray.origin, center), out);
		const step = gm.dot(ray.direction, out);
		if (Math.abs(step) < 1e-3 * Math.abs(offset)) return null;
		const t = -offset / step;
		return gm.add(ray.origin, gm.scale(t, ray.direction));
	}

	const begin = mousePt();
	if (begin === null) {
		console.warn("Trying to start drag from null point -- cancelling.");
		return;
	}

	function cancelGrab() {
		console.log("Cancelling grab.");
		cell.vertices = startVertices;
		cell.xform = startXform;
		ACTION = null;
		cellDirty(cell);
	}

	ACTION = {
		mousedown:(evt,mouse) => {
			if (evt.button == 0) {
				console.log("Confirming grab.");
				pushCommand({type: "confirmGrabCell", cellIndex: body.cells.indexOf(cell),
				             startVertices: startVertices, startXform: startXform,
				             endVertices: cell.vertices, endXform: cell.xform});
				ACTION = null;
				cellDirty(cell);
			} else if (evt.button == 2) {
				cancelGrab();
			}
		},
		//nothing: mouseup:(evt,mouse) => { },
		mousemove:(evt,mouse) => {
			MOUSE.x = mouse.x;
			MOUSE.y = mouse.y;
			const at = mousePt();
			if (at !== null) {
				const delta = gm.sub(at,begin);
				for (let i = 0; i < cell.vertices.length; ++i) {
					cell.vertices[i] = gm.add(startVertices[i], delta);
				}
				cell.xform = gm.rigidTransform(cell.template.vertices, cell.vertices); //could compute directly from starting xform but this is not performace-critical code
				cellDirty(cell);
			}
		},
		keydown:(evt) => {
			if (evt.code === 'Escape') {
				cancelGrab();
			}
		}
	};
}

/**
 * startCameraMove()
 */
function startCameraMove() {
	let oldACTION = ACTION;
	camFlipX = (camera.computeUp()[2] < 0.0);

	ACTION = {
		//ignore: mousedown:(evt,mouse) => { },
		mouseup:(evt,mouse) => {
			if (evt.button === 0) {
				ACTION = oldACTION;
				return;
			}
		},
		mousemove:(evt,mouse) => {
			if (MOUSE.x !== MOUSE.x) return;
			if (evt.shiftKey) {
				const up = camera.computeUp();
				const right = camera.computeRight();

				const x = camera.radius * (mouse.x - MOUSE.x) * Math.tan(0.5 * camera.fovy / 180.0 * Math.PI) * camera.aspect;
				const y = camera.radius * (mouse.y - MOUSE.y) * Math.tan(0.5 * camera.fovy / 180.0 * Math.PI);

				camera.target = gm.sub(camera.target, gm.add(gm.scale(x, right), gm.scale(y, up)));
			} else {
				const deltaToAngle = 2.0 * camera.fovy / 180.0 * Math.PI;
				camera.azimuth += (camFlipX ? -1.0 : 1.0) * -(mouse.x - MOUSE.x) * camera.aspect * deltaToAngle;
				camera.elevation -= (mouse.y - MOUSE.y) * deltaToAngle;
			}
			requestRedraw();
		}
	};
}

//--- vector math library ---

function viewFront() {
	camera.azimuth = Math.PI / 2.;
	camera.elevation = 0;
}

function viewSide() {
	camera.azimuth = 0;
	camera.elevation = 0;
}

function viewTop() {
	camera.azimuth = Math.PI / 2.;
	camera.elevation = Math.PI / 2.;
}

function lookAt(eye, target, up) {
	var out = gm.normalize(gm.sub(eye, target));
	var proj = gm.dot(up, out);
	up = gm.normalize( gm.sub(up, gm.scale(proj, out) ) );

	var right = gm.cross(up, out);

	var offset = gm.vec3(-gm.dot(eye, right), -gm.dot(eye, up), -gm.dot(eye, out));

	return new Float32Array([
		right[0], up[0], out[0], 0.0,
		right[1], up[1], out[1], 0.0,
		right[2], up[2], out[2], 0.0,
		offset[0], offset[1], offset[2], 1.0
	]);
}

function perspective(fovy, aspect, zNear) {
	var f = 1 / Math.tan(fovy/2 * Math.PI / 180.0);
	return new Float32Array([
		f / aspect, 0.0, 0.0, 0.0,
		0.0, f, 0.0, 0.0,
		0.0, 0.0, -1, -1.0,
		0.0, 0.0,-2.0 * zNear, 0.0
	]);
}
function orthographic(r, aspect, zNear, zFar) {
	var f = 1 / r;
	const eps = 1. / (zFar - zNear);
	
	return new Float32Array([
		f / aspect, 0.0, 0.0, 0.0,
		0.0, f, 0.0, 0.0,
		0.0, 0.0, - eps, 0.0,
		0.0, 0.0, 0.0, 1.0
	]);
}
function mul(A, B) {
	var out = new Float32Array(16);
	for (var r = 0; r < 4; ++r) {
		for (var c = 0; c < 4; ++c) {
			var val = 0.0;
			for (var k = 0; k < 4; ++k) {
				val += A[k * 4 + r] * B[c * 4 + k];
			}
			out[4 * c + r] = val;
		}
	}
	return out;
}

function computeMVP() {
	/*//DEBUG:
	return new Float32Array([
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 0.0, 1.0
	]);*/
	const P = viewPerspective ? perspective(camera.fovy, camera.aspect, 0.1) : orthographic(camera.radius * 0.35, camera.aspect, 0.1, 500.);
	const up = camera.computeUp();
	const MV = lookAt(
		camera.computeAt(),
		camera.target,
		up
	);
	return mul(P, MV);
}

//------- benchmark -------

/*
function benchmark() {
	console.log("Running benchmark....");

	//Okay, how to benchmark renderer? Consistent frame size, camera position, yarns.

	canvas.style.width = "1024px";
	canvas.style.height = "1024px";

	setBenchmarkYarns();

	camera.target = {x:0.0, y:0.0, z:0.0};
	camera.radius = 37;
	camera.azimuth = 0.0;
	camera.elevation = 0.0;
	camera.fovy = 60.0;
	camera.aspect = 1.0;

	let before = performance.now();
	let iters = 0;
	while (iters < 1000) {
		++iters;
		redraw();
		gl.finish();
		let after = performance.now();
		if (after - before > 2000) break;
	}
	let total = performance.now() - before;
	console.log("Did " + iters + " iterations in " + total + "ms.");
	let result = iters.toString() + " iterations, avg " + total/iters + "ms per";
	document.getElementById("benchmark-result").innerText = result;
}

document.getElementById("benchmark").addEventListener('click', benchmark);
*/

//------- rendering -------

//very simple shader program for vertex-colored things:
const colorProgram = new Program(gl,
`
	uniform mat4 LOCAL_TO_CLIP;

	attribute vec4 Position;
	attribute vec3 Normal;
	attribute vec4 Color;

	varying vec4 color;
	varying vec3 normal;

	void main() {
		gl_Position = LOCAL_TO_CLIP * Position;
		color = Color;
		normal = Normal;
	}
`,`
	uniform highp vec3 HEMI_DIRECTION;
	uniform lowp vec4 TINT;
	varying lowp vec4 color;
	varying highp vec3 normal;
	void main() {
		highp vec3 n = normalize(normal);
		//upper dome light:
		highp vec3 light = mix(vec3(0.1), vec3(1.0), 0.5*dot(n, HEMI_DIRECTION)+0.5);
		gl_FragColor = TINT * vec4(color.rgb * light, color.a);
	}
`);
window.colorProgram = colorProgram; //DEBUG

const textureProgram = new Program(gl,
`
	uniform mat4 LOCAL_TO_CLIP;

	attribute vec4 Position;
	attribute vec3 Normal;
	attribute vec2 UV;
	attribute vec4 Color;
	attribute float CellID;

	varying vec4 color;
	varying vec2 uv;
	varying vec3 normal;
	varying float cellID;

	void main() {
		gl_Position = LOCAL_TO_CLIP * Position;
		color = Color;
		uv = UV;
		normal = Normal;
		cellID = CellID;
	}
`,`
	uniform highp vec3 HEMI_DIRECTION;
	uniform lowp vec4 TINT;
	uniform lowp float TEX_STRENGTH;
	varying lowp vec4 color;
	varying highp vec2 uv;
	varying highp vec3 normal;
	varying highp float cellID;
    uniform sampler2D uSampler;
    uniform highp float selectedCellID;
	uniform lowp vec4 selectedColor;
	void main() {
		highp vec3 n = normalize(normal);
		//upper dome light:
		highp vec3 light = mix(vec3(0.1), vec3(1.0), 0.5*dot(n, HEMI_DIRECTION)+0.5);

		// treat texture as a mask
      	lowp float mask = texture2D(uSampler, uv).r;
      	mask = (1.-TEX_STRENGTH) + TEX_STRENGTH * (1. + mask) / 2.;
      	highp float selected = (abs(cellID - selectedCellID) < 0.01) ? 1. : 0.;
      	lowp vec4 compositeColor = selected * selectedColor + (1.-selected) * color;
		gl_FragColor = TINT * vec4(mask * compositeColor.rgb * light, color.a);
	}
`);
window.textureProgram = textureProgram; //DEBUG


//when using a data view to store Float32 values, do they need to be marked as little endian?
const FLOAT32_LITTLE_ENDIAN = function() {
	let array = new ArrayBuffer(4);
	let f32 = new Float32Array(array);
	let data = new DataView(array);
	f32[0] = 1.0;
	if (data.getFloat32(0, false) === f32[0]) {
		assert(data.getFloat32(0, true) !== f32[0]);
		return false;
	} else if (data.getFloat32(0, true) === f32[0]) {
		assert(data.getFloat32(0, false) !== f32[0]);
		return true;
	}
};

class Grid extends Geometry {
	constructor() {
		const BYTES_PER_ATTRIB = 4*2 + 1*4;
		const RADIUS = 10;

		const arrayBuffer = new ArrayBuffer(4*(2*RADIUS+1+1) * BYTES_PER_ATTRIB);
		const data = new DataView(arrayBuffer);

		let dataOffset = 0;

		function attrib(x,y, rgba) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}

		/*
		//axes:
		line({x:0,y:0,z:0},{x:5,y:0,z:0}, 0xff0000ff);
		line({x:0,y:0,z:0},{x:0,y:5,z:0}, 0x00ff00ff);
		line({x:0,y:0,z:0},{x:0,y:0,z:5}, 0x0000ffff);
		*/


		for (let x = -RADIUS; x <= RADIUS; ++x) {
			if (x === 0) {
				attrib(x,-RADIUS, 0x008800ff);
				attrib(x, 0, 0x008800ff);
				attrib(x, 0, 0x88ff88ff);
				attrib(x, RADIUS, 0x88ff88ff);
			} else {
				const col = (x == 0 ? 0x88ff88ff : 0x888888ff);
				attrib(x,-RADIUS, 0x888888ff);
				attrib(x, RADIUS, 0x888888ff);
			}
		}
		for (let y = -RADIUS; y <= RADIUS; ++y) {
			if (y === 0) {
				attrib(-RADIUS,y, 0x880000ff);
				attrib( 0,y, 0x880000ff);
				attrib( 0,y, 0xff8888ff);
				attrib( RADIUS,y, 0xff8888ff);
			} else {
				attrib(-RADIUS,y, 0x888888ff);
				attrib( RADIUS,y, 0x888888ff);
			}
		}

		console.assert(dataOffset === arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		const buffer = gl.createBuffer();
		const count = arrayBuffer.byteLength / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);

		const attribs = {
			Position:{buffer:buffer, size:2, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*2},
			Normal:[0.0, 0.0, 1.0]
		};

		super(gl, attribs, gl.LINES, count);
	}
}
const grid = new Grid();
window.grid = grid; //DEBUG

//Some predefined colors:
const COLOR_OUTPUT_WARNING = 0x881111ff;
const COLOR_INPUT_WARNING = 0xff2222ff;
const COLOR_OUTPUT = 0x888888ff;
const COLOR_INPUT = 0xffffffff;

//helper for color conversion from '#rrggbb', '#rrggbbaa', '#rgb', and '#rgba' to 0xrrggbbaa
function css2Uint32(color) {
	let val;
	if        (color.length === 9) {
		val = parseInt('0x' + color.substr(1));
	} else if (color.length === 7) {
		val = parseInt('0x' + color.substr(1)) * 256 + 255;
	} else if (color.length === 5) {
		val = parseInt('0x' + color.substr(1));
		const r = (val & 0xf000);
		const g = (val & 0x0f00);
		const b = (val & 0x00f0);
		const a = (val & 0x000f);
		//why are these not bit-shifts? because those coerce numbers to *signed* int32s integers (vs remaining float64's, which have 50-ish bits of integer precision)
		val = (r * 16 + r);
		val = val * 256 + (g * 16 + g);
		val = val * 256 + (b * 16 + b);
		val = val * 256 + (a * 16 + a);
	} else if (color.length === 4) {
		val = parseInt('0x' + color.substr(1));
		const r = (val & 0xf000);
		const g = (val & 0x0f00);
		const b = (val & 0x00f0);
		val = (r * 16 + r);
		val = val * 256 + (g * 16 + g);
		val = val * 256 + (b * 16 + b);
		val = val * 256 + 255;
	}
	return val;
}

function rgb2Uint32(color) {
	let val;
	val = Math.max(0, Math.min(255, Math.round(255 * color[0])));
	val = val * 256 + Math.max(0, Math.min(255, Math.round(255 * color[1])));
	val = val * 256 + Math.max(0, Math.min(255, Math.round(255 * color[2])));
	val = val * 256 + 255;
	return val;
}

function rgba2Uint32(color) {
	let val;
	val = Math.max(0, Math.min(255, Math.round(255 * color[0])));
	val = val * 256 + Math.max(0, Math.min(255, Math.round(255 * color[1])));
	val = val * 256 + Math.max(0, Math.min(255, Math.round(255 * color[2])));
	val = val * 256 + Math.max(0, Math.min(255, Math.round(255 * color[3])));
	return val;
}

function checkCellVisible(cell) {
	let zmax = null, zmin = null;
	for (const v of cell.vertices) {
		if (zmax == null || v[2] > zmax) zmax = v[2];
		if (zmin == null || v[2] < zmin) zmin = v[2];
	}

	// const h = zmax - zmin;
	const h = 1; //HACK: standardize height to 1?
	const layer = Math.round((zmax + zmin) / (2 * h));
	const layerVisibilityBoxes = document.getElementById("layer-visibility-form");
	return !(layer >= 0 && layer < layerVisibilityBoxes.length) || layerVisibilityBoxes[layer].checked;
}

class VisBody extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 4*3 + 1*4; //Position, Normal, Color
	constructor() {
		const BYTES_PER_ATTRIB = VisBody.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:4*3},
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3 + 4*3},
		};

		super(gl, attribs, gl.TRIANGLES, 0);

		this.buffer = buffer; //needed for set()
	}
	set(body) {
		const BYTES_PER_ATTRIB = VisBody.BYTES_PER_ATTRIB;

		//figure out how much space to allocate for attributes:
		let totalAttribs = 0;
		for (const cell of body.cells) {
			for (const face of cell.template.faces) {
				totalAttribs += 3 * (face.indices.length - 2);
			}
		}

		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * totalAttribs);
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		function attrib(x,y,z, nx,ny,nz, rgba) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, z, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setFloat32(dataOffset, nx, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, ny, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, nz, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}
		
		function triangle(va,vb,vc, color) {
			let n = gm.normalize(gm.cross(gm.sub(vb, va), gm.sub(vc, va)));
			attrib(va[0],va[1],va[2], n[0],n[1],n[2], color);
			attrib(vb[0],vb[1],vb[2], n[0],n[1],n[2], color);
			attrib(vc[0],vc[1],vc[2], n[0],n[1],n[2], color);
		}
		for (const cell of body.cells) {
			for (const face of cell.template.faces) {
				for (let i = 2; i < face.indices.length; ++i) {
					triangle(
						cell.vertices[face.indices[0]], cell.vertices[face.indices[i-1]], cell.vertices[face.indices[i]],
						css2Uint32(face.color));
					
				}
			}
		}

		console.assert(dataOffset === arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = arrayBuffer.byteLength / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);
	}
}
const visBody = new VisBody();
const visTemplateBody = new VisBody();
window.visBody = visBody; //DEBUG

//compute cell center point, face centers, and port vertices (used for drawing stuff):
function setCellDrawingInfo(cell) {
	{ //set center:
		let center = gm.vec3(0.0);
		for (let v of cell.vertices) {
			center = gm.add(center, v);
		}
		center = gm.scale(1.0 / cell.vertices.length, center);
		cell.center = center;
	}

	let ports = [];
	let centers = [];
	for (const face of cell.template.faces) {
		let center = gm.vec3(0.0);
		for (let vi of face.indices) {
			center = gm.add(center, cell.vertices[vi]);
		}
		center = gm.scale(1.0 / face.indices.length, center);
		centers.push(center);

		let port = [];
		for (let i = 0; i < face.indices.length; ++i) {
			let v = cell.vertices[face.indices[i]];
			v = gm.mix(v, center, 0.5); //move toward center of face
			port.push(v);
		}
		ports.push(port);
	}
	cell.ports = ports;
	cell.centers = centers;
}

function deleteCellDrawingInfo(cell) {
	delete cell.center;
	delete cell.ports;
	delete cell.centers;
}

class VisWire extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 1*4; //Position, Color
	constructor() {
		const BYTES_PER_ATTRIB = VisWire.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:[0,0,1],
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3},
		};

		super(gl, attribs, gl.LINES, 0);

		this.buffer = buffer; //needed for set()
	}
	set(body) {
		const BYTES_PER_ATTRIB = VisWire.BYTES_PER_ATTRIB;

		const SHOW_INTERNAL_FACES = false;
		const SHOW_TIGHT_CONNECTIONS = false;
		const SHOW_MISSING_CONNECTIONS = true;

		//figure out how much space to allocate for attributes:
		let totalAttribs = 0;
		for (const cell of body.cells) {
			for (let fi = 0; fi < cell.template.faces.length; ++fi) {
				const face = cell.template.faces[fi];
				totalAttribs += face.indices.length * 2 + 4;
				const con = cell.connections[fi];
				if (con !== null) totalAttribs += face.indices.length * 3;
				else if (face.type !== 'x') totalAttribs += face.indices.length * 2;
			}
			for (const yarn of cell.template.yarns) {
				totalAttribs += (yarn.pts.length-1)*2;
			}
		}

		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * totalAttribs);
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		function attrib(x,y,z, rgba) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, z, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}

		for (const cell of body.cells) {
			setCellDrawingInfo(cell);
		}

		for (const cell of body.cells) {
			//yarns:
			const xf = cell.xform;
			for (const yarn of cell.template.yarns) {
				let prev = null;
				let col = rgb2Uint32([1.0, 0.6, 0.5]);
				for (const pt of yarn.pts) {
					let at = gm.mul_mat4x3_vec4(xf, [...pt, 1]);
					if (prev !== null) {
						attrib(prev[0],prev[1],prev[2], col);
						attrib(at[0],at[1],at[2], col);
					}
					prev = at;
				}
			}

			//faces:
			for (let fi = 0; fi < cell.template.faces.length; ++fi) {
				if (!SHOW_INTERNAL_FACES) {
					//skip faces which are connected tightly:
					const connection = cell.connections[fi];
					if (connection !== null) {
						const ofs = gm.sub(connection.cell.centers[connection.face], cell.centers[fi]);
						const length2 = gm.dot(ofs,ofs);
						if (length2 < 0.1 * 0.1) {
							continue;
						}
					}
				}
				const face = cell.template.faces[fi];
				const center = cell.centers[fi];
				for (let i = 0; i < face.indices.length; ++i) {
					let a = cell.vertices[face.indices[i]];
					let b = cell.vertices[face.indices[(i+1)%face.indices.length]];
					a = gm.add(gm.scale(0.9, gm.sub(a, center)), center);
					b = gm.add(gm.scale(0.9, gm.sub(b, center)), center);
					let col = css2Uint32(face.color);
					attrib(a[0],a[1],a[2], col);
					attrib(b[0],b[1],b[2], col);
					if (i === 0 && face.type !== 'x') { //show "first edge" (for non-'x' face types)
						let c = gm.scale(0.5, gm.add(a,b));
						c = gm.add(gm.scale(0.9, gm.sub(c, center)), center);
						attrib(a[0],a[1],a[2], col);
						attrib(c[0],c[1],c[2], col);
						attrib(c[0],c[1],c[2], col);
						attrib(b[0],b[1],b[2], col);
					}
				}
			}

			//connections:
			for (let fi = 0 ; fi < cell.connections.length; ++fi) {
				const connection = cell.connections[fi];
				if (connection === null) {
					if (cell.template.faces[fi].type[0] !== 'x' && SHOW_MISSING_CONNECTIONS) {
						const col = (cell.template.faces[fi].type[0] === '+' ? COLOR_OUTPUT_WARNING : COLOR_INPUT_WARNING);
						for (let i = 0; i < cell.ports[fi].length; ++i) {
							let a = cell.ports[fi][i];
							let ca = gm.mix(a, cell.center, 0.1);
							attrib(ca[0], ca[1], ca[2], col); attrib(a[0], a[1], a[2], col);
						}
					}
					continue;
				}
				if (cell.template.faces[fi].type[0] !== '+') continue; //draw connectsions from '+' => '-'

				let maxLength2 = 0;
				const watermark = dataOffset;
				sv.forAlignedIndices(cell.template.faces[fi], connection.cell.template.faces[connection.face], (i, ci) => {
					let colOut = COLOR_OUTPUT;
					let colIn = COLOR_INPUT;
					if (!sv.canConnectFaces(cell.template.faces[fi], connection.cell.template.faces[connection.face])) {
						//apparently somehow this connection got made though it shouldn't be allowed:
						colOut = COLOR_OUTPUT_WARNING;
						colIn = COLOR_INPUT_WARNING;
					}
					let a = cell.ports[fi][i];
					let ca = gm.mix(a, cell.center, 0.1);
					let b = connection.cell.ports[connection.face][ci];
					let cb = gm.mix(b, connection.cell.center, 0.1);
					attrib(ca[0], ca[1], ca[2], colOut); attrib(a[0], a[1], a[2], colOut);
					attrib(a[0], a[1], a[2], colOut); attrib(b[0], b[1], b[2], colIn);
					attrib(b[0], b[1], b[2], colIn); attrib(cb[0], cb[1], cb[2], colIn);

					if (!SHOW_TIGHT_CONNECTIONS) {
						const ofs = gm.sub(b,a);
						const length2 = gm.dot(ofs,ofs);
						maxLength2 = Math.max(maxLength2, length2);
					}
				} );

				if (!SHOW_TIGHT_CONNECTIONS) {
					if (maxLength2 < 0.01 * 0.01) {
						dataOffset = watermark;
					}
				}
			}
		}

		
		//remove temp stuff:
		for (const cell of body.cells) {
			deleteCellDrawingInfo(cell);
		}


		//with various skipping may actually under-fill:
		console.assert(dataOffset <= arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = dataOffset / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);
	}
}

const visWire = new VisWire();
const visTemplateWire = new VisWire();
window.visWire = visWire; //DEBUG


class VisWireCells extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 1*4; //Position, Color
	constructor(respectVisibility=true) {
		const BYTES_PER_ATTRIB = VisWireCells.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:[0,0,1],
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3},
		};

		super(gl, attribs, gl.LINES, 0);

		this.buffer = buffer; //needed for set()
		this.respectVisibility = respectVisibility;
	}
	set(body) {
		const BYTES_PER_ATTRIB = VisWireCells.BYTES_PER_ATTRIB;

		const SHOW_INTERNAL_FACES = false;
		const SHOW_TIGHT_CONNECTIONS = false;
		const SHOW_MISSING_CONNECTIONS = true;

		//figure out how much space to allocate for attributes:
		let totalAttribs = 0;
		for (const cell of body.cells) {
			if (this.respectVisibility && (!checkCellVisible(cell))) continue;
			for (let fi = 0; fi < cell.template.faces.length; ++fi) {
				const face = cell.template.faces[fi];
				totalAttribs += face.indices.length * 2 + 4;
				const con = cell.connections[fi];
				if (con !== null) totalAttribs += face.indices.length * 3;
				else if (face.type !== 'x') totalAttribs += face.indices.length * 2;
			}
		}

		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * totalAttribs);
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		function attrib(x,y,z, rgba) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, z, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}

		for (const cell of body.cells) {
			setCellDrawingInfo(cell);
		}

		for (const cell of body.cells) {
			if (this.respectVisibility && (!checkCellVisible(cell))) continue;
			//faces:
			for (let fi = 0; fi < cell.template.faces.length; ++fi) {
				if (!SHOW_INTERNAL_FACES) {
					//skip faces which are connected tightly:
					const connection = cell.connections[fi];
					if (connection !== null) {
						const ofs = gm.sub(connection.cell.centers[connection.face], cell.centers[fi]);
						const length2 = gm.dot(ofs,ofs);
						if (length2 < 0.1 * 0.1) {
							continue;
						}
					}
				}
				const face = cell.template.faces[fi];
				const center = cell.centers[fi];
				for (let i = 0; i < face.indices.length; ++i) {
					let a = cell.vertices[face.indices[i]];
					let b = cell.vertices[face.indices[(i+1)%face.indices.length]];
					a = gm.add(gm.scale(0.9, gm.sub(a, center)), center);
					b = gm.add(gm.scale(0.9, gm.sub(b, center)), center);
					let col = css2Uint32("#aaaaaa");//css2Uint32(face.color);
					attrib(a[0],a[1],a[2], col);
					attrib(b[0],b[1],b[2], col);
					if (i === 0 && face.type !== 'x') { //show "first edge" (for non-'x' face types)
						let c = gm.scale(0.5, gm.add(a,b));
						c = gm.add(gm.scale(0.9, gm.sub(c, center)), center);
						attrib(a[0],a[1],a[2], col);
						attrib(c[0],c[1],c[2], col);
						attrib(c[0],c[1],c[2], col);
						attrib(b[0],b[1],b[2], col);
					}
				}
			}

			//connections:
			for (let fi = 0 ; fi < cell.connections.length; ++fi) {
				const connection = cell.connections[fi];
				if (connection === null) {
					if (cell.template.faces[fi].type[0] !== 'x' && SHOW_MISSING_CONNECTIONS) {
						const col = (cell.template.faces[fi].type[0] === '+' ? COLOR_OUTPUT_WARNING : COLOR_INPUT_WARNING);
						for (let i = 0; i < cell.ports[fi].length; ++i) {
							let a = cell.ports[fi][i];
							let ca = gm.mix(a, cell.center, 0.1);
							attrib(ca[0], ca[1], ca[2], col); attrib(a[0], a[1], a[2], col);
						}
					}
					continue;
				}
				if (cell.template.faces[fi].type[0] !== '+') continue; //draw connectsions from '+' => '-'

				let maxLength2 = 0;
				const watermark = dataOffset;
				sv.forAlignedIndices(cell.template.faces[fi], connection.cell.template.faces[connection.face], (i, ci) => {
					let colOut = COLOR_OUTPUT;
					let colIn = COLOR_INPUT;
					if (!sv.canConnectFaces(cell.template.faces[fi], connection.cell.template.faces[connection.face])) {
						//apparently somehow this connection got made though it shouldn't be allowed:
						colOut = COLOR_OUTPUT_WARNING;
						colIn = COLOR_INPUT_WARNING;
					}
					let a = cell.ports[fi][i];
					let ca = gm.mix(a, cell.center, 0.1);
					let b = connection.cell.ports[connection.face][ci];
					let cb = gm.mix(b, connection.cell.center, 0.1);
					attrib(ca[0], ca[1], ca[2], colOut); attrib(a[0], a[1], a[2], colOut);
					attrib(a[0], a[1], a[2], colOut); attrib(b[0], b[1], b[2], colIn);
					attrib(b[0], b[1], b[2], colIn); attrib(cb[0], cb[1], cb[2], colIn);

					if (!SHOW_TIGHT_CONNECTIONS) {
						const ofs = gm.sub(b,a);
						const length2 = gm.dot(ofs,ofs);
						maxLength2 = Math.max(maxLength2, length2);
					}
				} );

				if (!SHOW_TIGHT_CONNECTIONS) {
					if (maxLength2 < 0.01 * 0.01) {
						dataOffset = watermark;
					}
				}
			}
		}

		
		//remove temp stuff:
		for (const cell of body.cells) {
			deleteCellDrawingInfo(cell);
		}


		//with various skipping may actually under-fill:
		console.assert(dataOffset <= arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = dataOffset / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);
	}
}

const visWireCells = new VisWireCells(false);
const visTemplateWireCells = new VisWireCells(false);
window.visWireCells = visWireCells; //DEBUG


class VisTubes extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 4*3 + 4*2 + 4*1 + 4*1; //Position, Normal, UV, Color, CellID
	constructor(solid=true, fixedVisibility=null) {
		const BYTES_PER_ATTRIB = VisTubes.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:4*3},
			UV:{buffer:buffer, size:2, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:4*3 + 4*3},
			CellID:{buffer:buffer, size:1, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:4*3 + 4*3 + 4*2},
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3 + 4*3 + 4*2 + 4*1},
		};

		super(gl, attribs, gl.TRIANGLES, 0);

		this.buffer = buffer; //needed for set()
		this.resolution = 6;
		this.radius = 0.08;
		this.solid = solid;
		this.col_rgb = [1.0, 0.6, 0.5];
		this.col_transparent = rgba2Uint32([...this.col_rgb, 0.1]);
		this.col_opaque = rgb2Uint32(this.col_rgb);
		this.selectedColor = [1.0, 0.4, 0.3, 1.0];
		this.fixedVisibility = fixedVisibility;
		this.empty = false;

		this.arrayBuffer = null;
	}
	setDirty() {
		this.arrayBuffer = null;
		this.dirty = true;
	}
	setAllCells(body) {
		this.setDirty();
		for (let cell of body.cells) cell.dirty = true;
		this.setDirtyCells(body);
	}
	setDirtyCells(body) {
		const BYTES_PER_ATTRIB = VisTubes.BYTES_PER_ATTRIB;
		if (!this.arrayBuffer) {
			//figure out how much space to allocate for attributes:
			let totalAttribs = 0;
			for (const cell of body.cells) {
				if (this.fixedVisibility === false || (this.fixedVisibility == null && checkCellVisible(cell) !== this.solid)) continue;
				for (const yarn of cell.template.yarns) {
					totalAttribs += (yarn.pts.length-1) * 6 /* attribs per triangulated quad */ * this.resolution;
				}
			}
			this.empty = (totalAttribs === 0);
			this.arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * totalAttribs);
		}

		const data = new DataView(this.arrayBuffer);
		let dataOffset = 0;
		function attrib(x,y,z, nx,ny,nz, u,v, rgba, id) {
			data.setFloat32(dataOffset, x, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, y, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, z, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setFloat32(dataOffset, nx, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, ny, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, nz, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setFloat32(dataOffset, 2.*u, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, 2.*v, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setFloat32(dataOffset, id, FLOAT32_LITTLE_ENDIAN); dataOffset += 4;

			data.setUint32(dataOffset, rgba, false); dataOffset += 4;
		}

		function triangle(va,vb,vc, na,nb,nc, uva,uvb,uvc, color, id) {
			let shadeSmooth = true;
			if (!shadeSmooth) {
				let n = gm.normalize(gm.cross(gm.sub(vb, va), gm.sub(vc, va)));
				na = n; nb = n; nc = n;
			}

			attrib(va[0],va[1],va[2], na[0],na[1],na[2], uva[0], uva[1], color, id);
			attrib(vb[0],vb[1],vb[2], nb[0],nb[1],nb[2], uvb[0], uvb[1], color, id);
			attrib(vc[0],vc[1],vc[2], nc[0],nc[1],nc[2], uvc[0], uvc[1], color, id);
		}

		function quad(a, na, uva, b, nb, uvb, c, nc, uvc, d, nd, uvd, color, id) {
			// triangulate by shortest diagonal
			const lac = gm.length2(gm.sub(c, a));
			const lbd = gm.length2(gm.sub(b, d));

			if (lac < lbd) {
				triangle(a, b, c, na, nb, nc, uva, uvb, uvc, color, id);
				triangle(a, c, d, na, nc, nd, uva, uvc, uvd, color, id);
			} else {
				triangle(a, b, d, na, nb, nd, uva, uvb, uvd, color, id);
				triangle(b, c, d, nb, nc, nd, uvb, uvc, uvd, color, id);
			}

		}

		function snapAxisAligned(T) {
			if (T[0] > 0.5) {
				return gm.vec3(1,0,0);
			} else if (T[0] < -0.5) {
				return gm.vec3(-1, 0, 0);
			} else if (T[1] > 0.5) {
				return gm.vec3(0, 1, 0);
			} else if (T[1] < -0.5) {
				return gm.vec3(0, -1, 0);
			} else if (T[2] > 0.5) {
				return gm.vec3(0, 0, 1);
			} else {
				return gm.vec3(0, 0, -1);
			}
		}

		function snappedFrame(T) {
			if (Math.abs(T[0]) > 0.9) {
				return {x: gm.vec3(0, T[0], 0), y: gm.vec3(0, 0, 1)};
			} else if (Math.abs(T[1]) > 0.9) {
				return {x: gm.vec3(0, 0, T[1]), y: gm.vec3(1, 0, 0)};
			} else {
				return {x: gm.vec3(T[2], 0, 0), y: gm.vec3(0, 1, 0)};
			}
		}

		for (let cellID = 0; cellID < body.cells.length; ++cellID) {
			const cell = body.cells[cellID];
			if (this.fixedVisibility === false || (this.fixedVisibility == null && checkCellVisible(cell) !== this.solid)) continue;

			if (!cell.dirty) { // if cell is clean, don't need to rewrite
				for (const yarn of cell.template.yarns) {
					dataOffset += (yarn.pts.length-1) * 6 * this.resolution * BYTES_PER_ATTRIB;
				}
				continue;
			}

			const col = this.solid ? this.col_opaque : this.col_transparent;

			//yarns:
			const xf = cell.xform;
			// skCAD added start
			// for (const yarn of cell.template.yarns) {
			for (let yarnIndex = 0; yarnIndex < cell.template.yarns.length; yarnIndex++) {
    			const yarn = cell.template.yarns[yarnIndex];

				// comment this when you want to show all yarns
				// Check yarn-based layer visibility
				if (!checkLayerVisibilityYarn(cell, yarnIndex)) {
					// Skip invisible yarns, but still advance dataOffset if needed
					dataOffset += (yarn.pts.length-1) * 6 * this.resolution * BYTES_PER_ATTRIB;
					continue;
				}

				// for indicate loop mode
				// Use individual yarn color if available, otherwise use default
				let yarnColor;
				if (cell.yarnColors && cell.yarnColors[yarnIndex]) {
					yarnColor = this.solid ? 
						rgba2Uint32([...cell.yarnColors[yarnIndex], 1.0]) : 
						rgba2Uint32([...cell.yarnColors[yarnIndex], 0.1]);
				} else {
					yarnColor = this.solid ? this.col_opaque : this.col_transparent;
				}
				// skCAD added end
				const generate_uv = yarn["oriented"];

				// define frame
				let frames = [];
				let prev, at, Tprev;
				let yarnLength = 0;
				for (let iP = 0; iP < yarn.pts.length; iP++) {
					if (iP == 0) { // special case for first point
						at = gm.mul_mat4x3_vec4(xf, [...yarn.pts[iP], 1]);
						const next = gm.mul_mat4x3_vec4(xf, [...yarn.pts[iP+1], 1]);
						Tprev = snapAxisAligned(gm.normalize(gm.sub(next,at))); // tangent vector along first edge
						frames.push(snappedFrame(Tprev));
						prev = at;
						at = next;
					} else if (iP + 1 == yarn.pts.length) { // special case for last point
						const Tnext = snapAxisAligned(gm.normalize(gm.sub(at, prev))); // tangent vector along last edge
						frames.push(snappedFrame(Tnext));
						yarnLength += gm.dist(prev, at);
					} else {
						const next = gm.mul_mat4x3_vec4(xf, [...yarn.pts[iP+1], 1]);
						const Tnext = gm.normalize(gm.sub(next, at)); // tangent vector along prev edge
						const T = gm.normalize(gm.add(Tprev, Tnext));

						// pick a starting direction for polygon. arbitrarily pick z axis, unless vector points mostly in z direction, then pick x axis
						let axis = (Math.abs(T[2]) < 0.7) ? gm.vec3(0, 0, 1) : gm.vec3(1, 0, 0);

						// find x and y directions at prev and at points by projecting axis onto orthogonal complement of vertex tangent vector, and taking 90 degree rotation
						let x = gm.normalize(gm.sub(axis, gm.scalarmul(gm.dot(axis, T),T)));
						let y = gm.cross(Tprev, x);

						frames.push({x: x, y: y});
						yarnLength += gm.dist(prev, at);
						prev = at;
						at = next;
						Tprev = Tnext;
					}
				}

				// scale length to nearest integer
				
				const roundLength = Math.round(yarnLength);
				const uScale = roundLength / yarnLength;

				// generate cylinder
				let x_prev, y_prev; // and still using prev
				let u = 0;
				let v_offset = 0;
				for (let iP = 1; iP < yarn.pts.length; iP++) {
					if (iP == 1) {
						prev = gm.mul_mat4x3_vec4(xf, [...yarn.pts[0], 1]);
						x_prev = frames[0].x;
						y_prev = frames[0].y;
					}
					const at = gm.mul_mat4x3_vec4(xf, [...yarn.pts[iP], 1]);
					const x_at = frames[iP].x;
					const y_at = frames[iP].y;
					const cs = gm.dot(x_prev, x_at);
					const sn = gm.dot(gm.normalize(gm.sub(at, prev)), gm.cross(x_at, x_prev));
					const twist = Math.atan2(sn, cs) / (2 * Math.PI);
					const offset = Math.round(twist * this.resolution) / this.resolution;
					const angleShift = (twist - offset);
					const du = gm.length(gm.sub(prev, at)) * uScale;

					// finally emit cylinder by drawing circles in x-y planes and connecting them by quads
					let pj_prev, pj_at, uvj_prev, uvj_at;
					for (let i=0; i<this.resolution; i++) {
						if (i==0) {
							const tj_prev = -1. / this.resolution;
							const tj_at = tj_prev + offset;
							uvj_prev = generate_uv ? gm.vec2(u, tj_prev + v_offset) : gm.vec2(0, 0);
							uvj_at = generate_uv ? gm.vec2(u+du, tj_prev - angleShift + v_offset) : gm.vec2(0, 0);

							pj_prev = gm.add(gm.scalarmul(this.radius * Math.cos(2 * Math.PI * tj_prev), x_prev),  gm.scalarmul(this.radius * Math.sin(2 * Math.PI * tj_prev), y_prev));
							pj_at = gm.add(gm.scalarmul(this.radius * Math.cos(2 * Math.PI * tj_at), x_at),  gm.scalarmul(this.radius * Math.sin(2 * Math.PI * tj_at), y_at));
						}
						const ti_prev = (i / this.resolution);
						const ti_at = ti_prev + offset;
						const uvi_prev = generate_uv ? gm.vec2(u, ti_prev + v_offset) : gm.vec2(0, 0);
						const uvi_at = generate_uv ? gm.vec2(u+du, ti_prev - angleShift + v_offset) : gm.vec2(0, 0);

						const pi_prev = gm.add(gm.scalarmul(this.radius * Math.cos(2 * Math.PI * ti_prev), x_prev),  gm.scalarmul(this.radius * Math.sin(2 * Math.PI * ti_prev), y_prev));
						const pi_at = gm.add(gm.scalarmul(this.radius * Math.cos(2 * Math.PI * ti_at), x_at),  gm.scalarmul(this.radius * Math.sin(2 * Math.PI * ti_at), y_at));
						// quad(gm.add(prev, pi_prev), pi_prev, uvi_prev, gm.add(at, pi_at), pi_at, uvi_at, gm.add(at, pj_at), pj_at, uvj_at, gm.add(prev, pj_prev), pj_prev, uvj_prev, col, cellID); // deleted for indicate loop mode skCAD
						quad(gm.add(prev, pi_prev), pi_prev, uvi_prev, gm.add(at, pi_at), pi_at, uvi_at, gm.add(at, pj_at), pj_at, uvj_at, gm.add(prev, pj_prev), pj_prev, uvj_prev, yarnColor, cellID); // added for indicate loop mode skCAD
						pj_prev = pi_prev; pj_at = pi_at; uvj_prev = uvi_prev; uvj_at = uvi_at;
					}

					u += du;
					v_offset -= offset + angleShift;
					prev = at;
					x_prev = x_at;
					y_prev = y_at;
				}
			}
		}

		console.assert(dataOffset === this.arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = dataOffset / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, this.arrayBuffer, gl.STATIC_DRAW);
	}
}

const visTubes = new VisTubes(true);
const visTransparentTubes = new VisTubes(false);
const visTemplateTubes = new VisTubes(true, true /* always solid */);
window.visTubes = visTubes; //DEBUG
window.visTransparentTubes = visTransparentTubes; //DEBUG
window.visTemplateTubes = visTemplateTubes; //DEBUG
const visPreviewTubes = new VisTubes(true, true /* always opaque */);
visPreviewTubes.col_rgb = [0.8, 0.6, 1.0];
visPreviewTubes.col_opaque = rgb2Uint32(visPreviewTubes.col_rgb);
// visPreviewTubes.col_transparent = rgba2Uint32([...visPreviewTubes.col_rgb, 0.1]);
// visPreviewTubes.col_rgb = rgba2Uint32([...visPreviewTubes.col_rgb, 0.5]); // increase opacity

class VisPreviewLines extends Geometry {
	static BYTES_PER_ATTRIB = 4*3 + 1*4; //Position, Color
	constructor() {
		const BYTES_PER_ATTRIB = VisPreviewLines.BYTES_PER_ATTRIB;

		const buffer = gl.createBuffer();

		const attribs = {
			Position:{buffer:buffer, size:3, type:gl.FLOAT, normalize:false, stride:BYTES_PER_ATTRIB, offset:0},
			Normal:[0,0,1],
			Color:{buffer:buffer, size:4, type:gl.UNSIGNED_BYTE, normalize:true, stride:BYTES_PER_ATTRIB, offset:4*3},
		};

		super(gl, attribs, gl.LINES, 0);

		this.buffer = buffer;
	}
	update() {
		const BYTES_PER_ATTRIB = VisPreviewLines.BYTES_PER_ATTRIB;

		let attribs = []; //x,y,z,color

		function line(a,b,color) {
			attribs.push(a[0],a[1],a[2],color);
			attribs.push(b[0],b[1],b[2],color);
		}

		//----- make debug/UI lines ----
		
		// cursor:
		if (CURSOR.x === CURSOR.x) {
			if (viewPerspective) { // draw in perspective view
				const ray = mouseRay();
				let r = camera.computeRight();
				let u = camera.computeUp();
				r = gm.scale(0.01, r);
				u = gm.scale(0.01, u);
				const c = gm.add(ray.origin, ray.direction);
				line(gm.add(c,r), gm.sub(c,r), 0xffff00ff);
				line(gm.add(c,u), gm.sub(c,u), 0xffff00ff);
			} else { // draw cursor in perspective view
			}
		}

		//currently hovered face:
		if (CURSOR.over !== null) {
			const cell = CURSOR.over.cell;
			const face = cell.template.faces[CURSOR.over.face];
			for (let i = 0; i < face.indices.length; ++i) {
				line(cell.vertices[face.indices[(i == 0 ? face.indices.length : i) - 1]], cell.vertices[face.indices[i]], 0xffff0088);
			}
		}

		//currently hovered grid cell:
		if (CURSOR.grid !== null) {
			const x = Math.floor(CURSOR.grid.x);
			const y = Math.floor(CURSOR.grid.y);

			line([x, y, 0], [x+1,y,0], 0xff00ffff);
			line([x+1,y, 0], [x+1,y+1,0], 0xff00ffff);
			line([x+1, y+1, 0], [x,y+1,0], 0xff00ffff);
			line([x,y+1,0], [x,y,0], 0xff00ffff);
		}

		//preview cell addition:
		const cell = previewCell();
		if (cell !== null) {
			setCellDrawingInfo(cell);

			//yarns:
			// const xf = cell.xform;
			// for (const yarn of cell.template.yarns) {
			// 	let prev = null;
			// 	let col = rgb2Uint32([1.0, 0.6, 0.5]);
			// 	for (const pt of yarn.pts) {
			// 		let at = gm.mul_mat4x3_vec4(xf, [...pt, 1]);
			// 		if (prev !== null) {
			// 			line(prev,at, col);
			// 		}
			// 		prev = at;
			// 	}
			// }

			//faces:
			for (let fi = 0; fi < cell.template.faces.length; ++fi) {
				const face = cell.template.faces[fi];
				const center = cell.centers[fi];
				for (let i = 0; i < face.indices.length; ++i) {
					let a = cell.vertices[face.indices[i]];
					let b = cell.vertices[face.indices[(i+1)%face.indices.length]];
					a = gm.add(gm.scale(0.9, gm.sub(a, center)), center);
					b = gm.add(gm.scale(0.9, gm.sub(b, center)), center);
					let col = css2Uint32(face.color);
					line(a,b,col);
					if (i === 0 && face.type !== 'x') { //decorate first edge
						let c = gm.scale(0.5, gm.add(a,b));
						c = gm.add(gm.scale(0.9, gm.sub(c, center)), center);
						line(a,c,col);
						line(c,b,col);
					}
				}
			}

			//compute drawing info for all connected cells:
			for (const connection of cell.connections) {
				if (connection !== null) setCellDrawingInfo(connection.cell);
			}

			//connections:
			for (let fi = 0 ; fi < cell.connections.length; ++fi) {
				const connection = cell.connections[fi];
				if (connection === null) {
					if (cell.template.faces[fi].type !== 'x') {
						const col = (cell.template.faces[fi].type[0] === '+' ? COLOR_OUTPUT_WARNING : COLOR_INPUT_WARNING);
						for (let i = 0; i < cell.ports[fi].length; ++i) {
							let a = cell.ports[fi][i];
							let ca = gm.mix(a, cell.center, 0.1);
							line(ca, a, col);
						}
					}
					continue;
				}

				sv.forAlignedIndices(cell.template.faces[fi], connection.cell.template.faces[connection.face], (i, ci) => {
					let colOut = COLOR_OUTPUT;
					let colIn = COLOR_INPUT;
					if (cell.template.faces[fi].type[0] === '-') {
						[colOut, colIn] = [colIn, colOut];
					}
					if (!sv.canConnectFaces(cell.template.faces[fi], connection.cell.template.faces[connection.face])) {
						//apparently somehow this connection got made though it shouldn't be allowed:
						colOut = COLOR_OUTPUT_WARNING;
						colIn = COLOR_INPUT_WARNING;
					}
					let a = cell.ports[fi][i];
					let ca = gm.mix(a, cell.center, 0.1);
					let b = connection.cell.ports[connection.face][ci];
					let cb = gm.mix(b, connection.cell.center, 0.1);
					attribs.push(ca[0], ca[1], ca[2], colOut); attribs.push(a[0], a[1], a[2], colOut);
					attribs.push(a[0], a[1], a[2], colOut); attribs.push(b[0], b[1], b[2], colIn);
					attribs.push(b[0], b[1], b[2], colIn); attribs.push(cb[0], cb[1], cb[2], colIn);
				} );
			}

			//remove temp drawing info:
			for (const connection of cell.connections) {
				if (connection !== null) deleteCellDrawingInfo(connection.cell);
			}

		}

		//---- copy debug lines to buffer for drawing ----

		//copy attribs to a formatted buffer:
		const arrayBuffer = new ArrayBuffer(BYTES_PER_ATTRIB * (attribs.length / 4));
		const data = new DataView(arrayBuffer);
		let dataOffset = 0;
		for (let i = 0; i < attribs.length; i += 4) {
			data.setFloat32(dataOffset, attribs[i+0], FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, attribs[i+1], FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setFloat32(dataOffset, attribs[i+2], FLOAT32_LITTLE_ENDIAN); dataOffset += 4;
			data.setUint32(dataOffset, attribs[i+3], false); dataOffset += 4;
		}

		console.assert(dataOffset === arrayBuffer.byteLength, `Bytes of attributes (${dataOffset}) matches allocated data size (${data.byteLength}).`);

		this.count = arrayBuffer.byteLength / BYTES_PER_ATTRIB;

		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STREAM_DRAW);
	}
}
const visPreviewLines = new VisPreviewLines();

let yarnVisMode = "Tube";
function setYarnVisMode(mode) {
	if (mode == "Wire") {
		yarnVisMode = "Wire";
	} else if (mode == "Body") {
		yarnVisMode = "Body";
	} else if (mode == "Tube") {
		yarnVisMode = "Tube";
	} else {
		console.log("Error, invalid vis mode ", mode);
	}
	bodyDirty();
	requestRedraw()
}

function setViewMode(mode) {
	const patternButton = document.getElementById("3dview-set-pattern-mode");
	const templateButton = document.getElementById("3dview-set-template-mode");
	// clear current mode
	patternButton.classList.remove("active");
	templateButton.classList.remove("active");

	if (mode == "Pattern") {
		patternButton.classList.add("active");
		viewMode = ViewMode.Pattern;
		bodyDirty();
	} else if (mode == "Template") {
		templateButton.classList.add("active");
		viewMode = ViewMode.Template;
		templateDirty();
	} else {
		console.log("Error, invalid view mode ", mode);
	}
	requestRedraw()
}

function setSidebar(mode) {
	const designButton = document.getElementById("sidebar-set-design-mode");
	const codegenButton = document.getElementById("sidebar-set-codegen-mode");
	const library = document.getElementById("library");
	const knitout = document.getElementById("view-knitout");
	const blockData = document.getElementById("view-block-data");
	const commands = document.getElementById("view-shortcuts");

	// clear current mode
	designButton.classList.remove("active");
	codegenButton.classList.remove("active");
	library.style.display = "none";
	knitout.style.display = "none";
	blockData.style.display ="none";
	commands.style.display = "none";

	if (mode == "PatternDesign") {
		library.style.display = "grid";
		knitout.style.display = "none";
		blockData.style.display = "none";
		commands.style.display = "grid";
		designButton.classList.add("active");
	} else if (mode == "CodeGen") {
		library.style.display = "none";
		knitout.style.display = "grid";
		blockData.style.display = "grid";
		commands.style.display = "none";
		codegenButton.classList.add("active");
	} else {
		console.log("Error, invalid sidebar mode ", mode);
	}
}

// set up response to clicking on visualization options
document.getElementById("select-yarn-vis-option").addEventListener("change", function() {setYarnVisMode(this.value);});
setYarnVisMode(document.getElementById("select-yarn-vis-option").value);

for (const elem of document.getElementById('layer-visibility-form').children) {
	elem.addEventListener('click', function() {bodyDirty();});
}

// yarn-based layer visibility
const layerVisibilityYarnForm = document.getElementById('layer-visibility-yarn-form');
if (layerVisibilityYarnForm) {
    for (const elem of layerVisibilityYarnForm.children) {
        elem.addEventListener('click', function() {
            // Clear layer visibility yarn cache
            layerVisibilityYarnCache = null;
            lastLayerVisibilityYarnPath = null;
            
            bodyDirty();
        });
    }
}

for (const elem of document.getElementById('show-yarn-direction-form').children) {
	elem.addEventListener('click', function() {bodyDirty();});
}

// document.getElementById("select-viewmode-option").addEventListener("change", function() {setViewMode(this.value);});
// setViewMode(document.getElementById("select-viewmode-option").value);
document.getElementById("select-3dview-mode").addEventListener("change", function(e) {setViewMode(e.target.value);});
// set sidebar to current selection
for (let child of document.getElementById("select-3dview-mode").children) {
	if (child.checked) {
		setViewMode(child.value);
		break;
	}
}

document.getElementById("select-sidebar-mode").addEventListener("change", function(e) {setSidebar(e.target.value);});
// set sidebar to current selection
for (let child of document.getElementById("select-sidebar-mode").children) {
	if (child.checked) {
		setSidebar(child.value);
		break;
	}
}

function setDarkMode(setDark) {
	const body = document.getElementsByTagName("body")[0];
	if (setDark) {
		body.classList.remove("lightmode");
		body.classList.add("darkmode");
	} else {
		body.classList.add("lightmode");
		body.classList.remove("darkmode");
	}
	requestRedraw(); // refresh canvas background
}
document.getElementById("darkmode-checkbox").addEventListener("change", function() {setDarkMode(this.checked);});
setDarkMode(document.getElementById("darkmode-checkbox").checked);

// To change the displayed knitout, set knitoutCode.text to a different value and call knitoutDirty() to request a refresh
const knitoutCode = {fragments: [] };


const groupKnitoutPassesCheckbox = document.getElementById('group-knitout-passes-form').children[1];
writeHighlightedCode(knitoutCode.fragments, document.getElementById("knitout-source"), groupKnitoutPassesCheckbox.checked);
groupKnitoutPassesCheckbox.addEventListener('click', function() {
	writeHighlightedCode(knitoutCode.fragments, document.getElementById("knitout-source"), groupKnitoutPassesCheckbox.checked);
});

function regenerateCode() {
	allocateSpots();
	knitoutCode.fragments = exportSolidKnitout(body);
	writeHighlightedCode(knitoutCode.fragments, document.getElementById("knitout-source"), groupKnitoutPassesCheckbox.checked);
}

// export machine code 
document.getElementById("regenerate-code").addEventListener('click', function(evt){
	regenerateCode();
	// .solidknitout, .sk, .solidk -- As a reference to the original knitout extension?
	//console.log(text);
		// fileSave(text, "solid-knitting.sk");
});


const postprocessProgram = new Program(gl,
`
	attribute vec2 Position;
	attribute vec2 TexCoord;
	varying vec2 texCoord;
	void main() {
		gl_Position = vec4(Position,0,1);
		texCoord = TexCoord;
	}
`,`
	uniform sampler2D DEPTH_SHADED_TEX;
	uniform sampler2D DEPTH_SHADED_DEPTH;
	uniform sampler2D NON_DEPTH_SHADED_TEX;
	uniform sampler2D NON_DEPTH_SHADED_DEPTH;
	uniform highp vec2 PX;
	varying highp vec2 texCoord;
	void main() {
		//gl_FragColor = vec4(1,0,1,1);
		//gl_FragColor = vec4(texCoord,1,1);
		//gl_FragColor = texture2D(DEPTH_SHADED_TEX, gl_FragCoord.xy/1000.0);
		//gl_FragColor = vec4(texture2D(DEPTH_SHADED_TEX, texCoord).r, texCoord, 1);
		mediump vec3 depth_shaded_color = texture2D(DEPTH_SHADED_TEX, texCoord).rgb;
		mediump vec3 non_depth_shaded_color = texture2D(NON_DEPTH_SHADED_TEX, texCoord).rgb;
		mediump float depth_shaded_depth = texture2D(DEPTH_SHADED_DEPTH, texCoord).r;
		mediump float non_depth_shaded_depth = texture2D(NON_DEPTH_SHADED_DEPTH, texCoord).r;

		//this is taken from autoknit:
		highp float ref = texture2D(DEPTH_SHADED_DEPTH, texCoord).r;
		highp float z = min(0.9999, ref);
		//over from depth component space -> projected z value:
		z = 2.0 * (z - 0.5);
		//from projected z value to world z value:
		#define NEAR 0.1
		z = (2.0 * NEAR) / (z - 1.0);
		//z is now in range [-inf, -NEAR]
		z += 0.5; //depth offset for maximum shade
		//back to projected space:
		z = 1.0 + (2.0 * NEAR) / z;
		z = 0.5 * z + 0.5;
		highp float amt = 1.0 / (z - ref);

		#define DO(X,Y) { \
			lowp float val = texture2D(DEPTH_SHADED_DEPTH, texCoord+vec2(X,Y)*PX*1.5).r; \
			tint += clamp((val - ref) * amt, 0.0, 1.0); \
		}

		#define R 3
		highp float tint = 0.0;
		mediump float w = 0.;
		for (int dy = -R; dy <= R; dy++) {
			for (int dx = -R; dx <= R; dx++) {
				if (!(dx == 0 && dy == 0)) {
					DO(dx, dy);
					w += 1.;
				}
			}
		}    
		tint = 1.0 - (tint / w);
		depth_shaded_color *= tint;
		gl_FragColor = depth_shaded_depth < non_depth_shaded_depth ? vec4(depth_shaded_color, 1) : vec4(non_depth_shaded_color, 1);
		// gl_FragColor = vec4(depth_shaded_color, 1);
	}
`);
window.postprocessProgram = postprocessProgram;


// Because lack of gl_VertexID in WEBGL1's GLSL means we can't do the lazy fullscreen-triangle-generated-by-vertex-shader trick:
class FullscreenTriangle extends Geometry {
	constructor() {
		const buffer = gl.createBuffer();
		const attribs = {
			Position:{buffer:buffer, size:2, type:gl.FLOAT, normalize:false, stride:4*4, offset:0},
			TexCoord:{buffer:buffer, size:2, type:gl.FLOAT, normalize:false, stride:4*4, offset:2*4}
		};
		super(gl, attribs, gl.TRIANGLES, 0);
		let data = new Float32Array([ -1,-1, 0,0,   3,-1, 2,0,  -1,3, 0,2 ]);
		this.buffer = buffer;
		this.count = 3;
		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
	}
}
const fullscreenTriangle = new FullscreenTriangle();
window.fullscreenTriangle = fullscreenTriangle; //DEBUG

// Applies screenspace depth shading to make crossings easier to interpret
class Postprocess {
	constructor() {
		this.w = 0;
		this.h = 0;
		if (ext_WEBGL_depth_texture) {
			console.log("Postprocessing enabled.");
			this.enabled = true;
		} else {
			console.log("Don't have WEBGL_depth_texture; postprocessing disabled.");
			this.enabled = false;
		}
	}
	resize(w,h) {
		if (!this.enabled) return;
		if (w === this.w && h === this.h) return;
		this.w = w;
		this.h = h;

		if (!('depth_shaded_depth_tex' in this)) this.depth_shaded_depth_tex = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.depth_shaded_depth_tex);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, w, h, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(gl.TEXTURE_2D, null);

		if (!('depth_shaded_color_tex' in this)) this.depth_shaded_color_tex = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.depth_shaded_color_tex);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, w, h, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(gl.TEXTURE_2D, null);

		if (!('depth_shaded_fb' in this)) {
			this.depth_shaded_fb = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.depth_shaded_fb);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.depth_shaded_color_tex, 0);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.depth_shaded_depth_tex, 0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.depth_shaded_fb);
		const depth_shaded_complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
		if (depth_shaded_complete !== gl.FRAMEBUFFER_COMPLETE) {
			console.log(`Failed to resize postprocessing framebuffer: ${depth_shaded_complete}`);
		}
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);

		if (!('non_depth_shaded_depth_tex' in this)) this.non_depth_shaded_depth_tex = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.non_depth_shaded_depth_tex);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, w, h, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(gl.TEXTURE_2D, null);

		if (!('non_depth_shaded_color_tex' in this)) this.non_depth_shaded_color_tex = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.non_depth_shaded_color_tex);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, w, h, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(gl.TEXTURE_2D, null);

		if (!('non_depth_shaded_fb' in this)) {
			this.non_depth_shaded_fb = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.non_depth_shaded_fb);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.non_depth_shaded_color_tex, 0);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.non_depth_shaded_depth_tex, 0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.non_depth_shaded_fb);
		const non_depth_shaded_complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
		if (non_depth_shaded_complete !== gl.FRAMEBUFFER_COMPLETE) {
			console.log(`Failed to resize postprocessing framebuffer: ${non_depth_shaded_complete}`);
		}
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	}
	//call before rendering that you want to postprocess:
	begin_depth_shaded() {
		if (!this.enabled) return;
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.depth_shaded_fb);
	}
	begin_non_depth_shaded() {
		if (!this.enabled) return;
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.non_depth_shaded_fb);
	}
	//call to copy post-processed stuff back to the screen:
	end() {
		if (!this.enabled) return;

		//for DEBUG purposes:
		if (!('check_tex' in this)) {
			this.check_tex = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, this.check_tex);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([
				255,255,255,255,  0,0,0,255,
				0,0,0,255,   255,255,255,255
			]));
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}

		gl.bindFramebuffer(gl.FRAMEBUFFER, null);

		gl.activeTexture(gl.TEXTURE3);
		gl.bindTexture(gl.TEXTURE_2D, this.non_depth_shaded_depth_tex);

		gl.activeTexture(gl.TEXTURE2);
		gl.bindTexture(gl.TEXTURE_2D, this.non_depth_shaded_color_tex);

		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, this.depth_shaded_depth_tex);

		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, this.depth_shaded_color_tex);

		gl.useProgram(postprocessProgram.program);
		gl.uniform1i(postprocessProgram.uniformLocations.DEPTH_SHADED_TEX, 0);
		gl.uniform1i(postprocessProgram.uniformLocations.DEPTH_SHADED_DEPTH, 1);
		gl.uniform1i(postprocessProgram.uniformLocations.NON_DEPTH_SHADED_TEX, 2);
		gl.uniform1i(postprocessProgram.uniformLocations.NON_DEPTH_SHADED_DEPTH, 3);
		gl.uniform2f(postprocessProgram.uniformLocations.PX, 1 / canvas.width, 1 / canvas.height);

		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.BLEND);
		// console.log("drawing");
		gl.clearColor(0.5,0.5,0.5,1.0);
		gl.clear(gl.COLOR_BUFFER_BIT);
		fullscreenTriangle.draw(postprocessProgram);

		gl.activeTexture(gl.TEXTURE3);
		gl.bindTexture(gl.TEXTURE_2D, null);

		gl.activeTexture(gl.TEXTURE2);
		gl.bindTexture(gl.TEXTURE_2D, null);

		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, null);

		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
}
const postprocess = new Postprocess();
window.postprocess = postprocess; //DEBUG

/**
 * redrawPatternNonDepthShaded(pixelRatio):
 * Draws the UI elements associated with the current pattern which we do not wish to depth shade (e.g. outlines, grid lines). */
function redrawPatternNonDepthShaded(pixelRatio) {
	visPreviewLines.update();

	//update status line:
	{
		let info = "";
		if (template !== null) {
			info += `Template: ${template.longsignature()}`;
		} else {
			info += `No Template`;
		}
		if (CURSOR.over) {
			info += `; Hovered: ${CURSOR.over.cell.template.longsignature()} / face: ${CURSOR.over.face} (${CURSOR.over.cell.template.faces[CURSOR.over.face].type})`;
		}
		STATUS_LINE.innerText = info;
	}

	// show info about hovered block in sidebar
	displayHoveredBlockInfo(CURSOR.over);
	// if (body.cells.length > 0) displayHoveredBlockInfo({cellID: 0, cell: body.cells[0]});

	gl.lineWidth(2.0 * pixelRatio);
	visPreviewLines.draw(colorProgram);

	gl.lineWidth(1.0 * pixelRatio);
	grid.draw(colorProgram);

	if (yarnVisMode == "Tube") {
		visWireCells.draw(colorProgram);
		// also draw transparent tubes here, since we need to disable depth testing
		// draw transparent tubes per https://xem.github.io/articles/webgl-guide-part-2.html#1a
		if (!visTransparentTubes.empty) {
			gl.useProgram(textureProgram.program);
			gl.enable(gl.BLEND);
			gl.blendEquation(gl.FUNC_ADD);
			gl.disable(gl.DEPTH_TEST);
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
			visTransparentTubes.draw(textureProgram);
			gl.enable(gl.DEPTH_TEST);
			gl.disable(gl.BLEND);
			gl.useProgram(colorProgram.program);
		}
	}

	//show "hidden" debug lines also:

	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	gl.uniform4f(
		colorProgram.uniformLocations.TINT,
		0.0, 0.0, 0.0, 0.1
	);
	gl.depthFunc(gl.GREATER);
	gl.depthMask(false);
	gl.lineWidth(2.0 * pixelRatio);
	visPreviewLines.draw(colorProgram);

	gl.depthFunc(gl.LESS);
	gl.depthMask(true);
	gl.disable(gl.BLEND);
}

/**
 * redrawPatternDepthShaded(pixelRatio)
 * Draws the components of the current pattern which we wish to depth shade (e.g. yarn tubes). */
function redrawPatternDepthShaded(pixelRatio) {

	const cell = previewCell();
	visPreviewTubes.setAllCells({cells: (cell ? [cell] : [])});
	
	if (yarnVisMode == "Body") {
		visBody.draw(colorProgram);
	} else if (yarnVisMode == "Wire") {
		visWire.draw(colorProgram);
	} else if (yarnVisMode == "Tube") {
		gl.useProgram(textureProgram.program);
		// draw opaque tubes
		if (!visTubes.empty) visTubes.draw(textureProgram);
		if (!visPreviewTubes.empty) visPreviewTubes.draw(textureProgram);
		gl.useProgram(colorProgram.program);

		// skCAD
		// fill null cell faces with color
		const unlabeledCells = body.cells.filter(cell =>
            cell.template.longname === "unlabeled.right.alt" ||
            cell.template.longname === "unlabeled.left.alt"
        );

        // fill previewed null cell faces with color
        if (cell && (
            cell.template.longname === "unlabeled.right.alt" ||
            cell.template.longname === "unlabeled.left.alt"
        )) {
            unlabeledCells.push(cell);
        }

        if (unlabeledCells.length > 0) {
            visBody.set({cells: unlabeledCells});
            visBody.draw(colorProgram);
        }
	}
}

/**
 * redrawTemplate(pixelRatio):
 * Draws the currently selected template. */
function redrawTemplate(pixelRatio) {
	function getTemplateBody(template) {
		if (template) {
			return {cells: [sv.Cell.fromTemplate(template, gm.identityTransform())]};
		} else {
			return {cells: []};
		}
	}

	// update the geometry
	if (yarnVisMode == "Wire" && visTemplateWire.dirty) {
		visTemplateWire.set(getTemplateBody(template));
		delete visTemplateWire.dirty;
	}
	if (visTemplateWireCells.dirty) {
		visTemplateWireCells.set(getTemplateBody(template));
		delete visTemplateWireCells.dirty;
	}
	if (yarnVisMode == "Body" && visTemplateBody.dirty) {
		visTemplateBody.set(getTemplateBody(template));
		delete visTemplateBody.dirty;
	}
	if (yarnVisMode == "Tube" && visTemplateTubes.dirty) {
		visTemplateTubes.setAllCells(getTemplateBody(template));
		delete visTemplateTubes.dirty;
	}

	//update status line:
	{
		let info = "";
		if (template !== null) {
			info += `Template: ${template.longsignature()}`;
		} else {
			info += `No Template`;
		}
		STATUS_LINE.innerText = info;
	}

	visPreviewLines.update();

	gl.lineWidth(1.0 * pixelRatio);
	grid.draw(colorProgram);

	
	if (yarnVisMode == "Body") {
		visTemplateBody.draw(colorProgram);
	} else if (yarnVisMode == "Wire") {
		visTemplateWire.draw(colorProgram);
	} else if (yarnVisMode == "Tube") {
		visTemplateWireCells.draw(colorProgram);

		gl.useProgram(textureProgram.program);
		visTemplateTubes.draw(textureProgram);
		gl.useProgram(colorProgram.program);
	}

	//show "hidden" debug lines also:

	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	gl.uniform4f(
		colorProgram.uniformLocations.TINT,
		0.0, 0.0, 0.0, 0.1
	);
	gl.depthFunc(gl.GREATER);
	gl.depthMask(false);
	gl.lineWidth(2.0 * pixelRatio);
	visPreviewLines.draw(colorProgram);

	gl.depthFunc(gl.LESS);
	gl.depthMask(true);
	gl.disable(gl.BLEND);
}

function redraw() {
	const pixelRatio = window.devicePixelRatio;

	let clearColor = [0.1, 0.1, 0.1];

	//make sure canvas size matches element size:
	(function resize() {
		const style = getComputedStyle(canvas);
		window.style = style;

		const width = Math.round(parseFloat(style.width) * pixelRatio);
		const height = Math.round(parseFloat(style.height) * pixelRatio);
		canvas.width = width;
		canvas.height = height;
		gl.viewport(0,0,width,height);
		camera.aspect = width / height;

		// read clearColor from CSS
		const rgbColor = style["background-color"];
		// Use a regular expression to extract the r,g,b components from a string of the form "rgb(r, g, b)".
		// The unescaped parentheses capture the r,g,b values which can be accessed as elements 1,2,3 of the returned match
		const matchResult = rgbColor.match(/^rgb\s*\(\s*(\d+),\s*(\d+),\s*(\d+)\)\s*$/);
		if (matchResult.length >= 4) clearColor = [matchResult[1]/255., matchResult[2]/255., matchResult[3]/255.];
	})();

	// Update displayed knitout code if necessary
	if (knitoutCode.dirty) {
		writeHighlightedCode(knitoutCode.fragments, document.getElementById("knitout-source"), groupKnitoutPassesCheckbox.checked);
		delete knitoutCode.dirty;
	}

	//update mouse info:
	if (CURSOR.dirty || MOUSE.dirty) setCursorOver();

	//update geometry:
	if (yarnVisMode == "Wire" && visWire.dirty) {
		visWire.set(body);
		delete visWire.dirty;
	}
	if (visWireCells.dirty) {
		visWireCells.set(body);
		delete visWireCells.dirty;
	}
	if (yarnVisMode == "Body" && visBody.dirty) {
		visBody.set(body);
		delete visBody.dirty;
	}
	if (yarnVisMode == "Tube" && visTubes.dirty) {
		visTubes.setDirtyCells(body);
		delete visTubes.dirty;
	}
	if (yarnVisMode == "Tube" && visTransparentTubes.dirty) {
		visTransparentTubes.setDirtyCells(body);
		delete visTransparentTubes.dirty;
	}
	bodyClean();

	//- - - - - - - - - - - - - - - - - - - -
	postprocess.resize(canvas.width, canvas.height);

	postprocess.begin_depth_shaded();
	gl.clearColor(clearColor[0], clearColor[1], clearColor[2], 1.0);

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LESS);

	gl.useProgram(colorProgram.program);

	gl.uniformMatrix4fv(
		colorProgram.uniformLocations.LOCAL_TO_CLIP,
		false,
		computeMVP()
	);

	const lightDir = gm.normalize(gm.add(camera.computeUp(),camera.computeOut()));
	gl.uniform3f(
		colorProgram.uniformLocations.HEMI_DIRECTION,
		lightDir[0], lightDir[1], lightDir[2]
	);
	gl.uniform4f(
		colorProgram.uniformLocations.TINT,
		1.0, 1.0, 1.0, 1.0
	);

	// if we're drawing tubes, set up the texture program as well
	if (yarnVisMode == "Tube") {

		gl.useProgram(textureProgram.program);
		gl.uniformMatrix4fv(
			textureProgram.uniformLocations.LOCAL_TO_CLIP,
			false,
			computeMVP()
		);
		const lightDir = gm.normalize(gm.add(camera.computeUp(),camera.computeOut()));
		gl.uniform3f(
			textureProgram.uniformLocations.HEMI_DIRECTION,
			lightDir[0], lightDir[1], lightDir[2]
		);
		gl.uniform4f(
			textureProgram.uniformLocations.TINT,
			1.0, 1.0, 1.0, 1.0
		);

		const show_texture = document.getElementById("show-yarn-direction-form")[0].checked;
		gl.uniform1f(
			textureProgram.uniformLocations.TEX_STRENGTH,
			(show_texture ? 1 : 0)
		);
		gl.uniform1f(
			textureProgram.uniformLocations.selectedCellID,
			// HACK: don't highlight selected cell in template view mode. Really, we should probably make CURSOR.over depend on mode
			(CURSOR.over === null || viewMode === ViewMode.Template) ?  -1. : CURSOR.over.cellID
		);
		gl.uniform4f(
			textureProgram.uniformLocations.TINT,
			1.0, 1.0, 1.0, 1.0
		);
		gl.uniform4f(
			textureProgram.uniformLocations.selectedColor,
			visTubes.selectedColor[0], visTubes.selectedColor[1], visTubes.selectedColor[2], visTubes.selectedColor[3]
		);

		// pass in texture
		// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, window.arrowTexture);
		gl.uniform1i(textureProgram.uniformLocations.uSampler, 0);

		gl.useProgram(colorProgram.program);
	}
	
	// draw yarn
	if (viewMode === ViewMode.Pattern) {
		redrawPatternDepthShaded(pixelRatio);
	} else if (viewMode === ViewMode.Template) {
		redrawTemplate(pixelRatio);
	}

	// prepare for UI pass (only used in pattern mode)
	postprocess.begin_non_depth_shaded();
	gl.clearColor(clearColor[0], clearColor[1], clearColor[2], 1.0);

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LESS);

	gl.useProgram(colorProgram.program);

	// if in pattern mode, draw UI separately
	if (viewMode === ViewMode.Pattern) {
		redrawPatternNonDepthShaded(pixelRatio);
	}

	postprocess.end();
	//- - - - - - - - - - - - - - - - - - - -

	// draw the stl mesh
	if (window._meshData && window._meshProgram) {
		drawGLMesh();
	}
	
}

function requestRedraw() {
	if (requestRedraw.requested) return;
	requestRedraw.requested = true;
	window.requestAnimationFrame(function(ts){
		delete requestRedraw.requested;
		redraw();
	});
}
window.requestRedraw = requestRedraw;

resetCamera();
requestRedraw();

window.addEventListener('resize', requestRedraw);

async function init() {
	{
		console.log(`Fetching library...`);
		//const request = await fetch('solid-knitting.library');
		const request = await fetch('block-library/blocks.json');
		const arrayBuffer = await request.arrayBuffer();
		console.log(`  got ${arrayBuffer.byteLength} bytes.`);

		window.library = sv.Library.fromArrayBuffer(arrayBuffer);
		listTemplates(window.library.templates);

		// //hack-y way of selecting first template:
		// window.template = null;
		// nextTemplate();
		
		// select default template
		for (const t of Object.values(window.library.templates)) {
			if (t.longname === "unlabeled.right.alt") {
				window.template = t;
				setActiveTemplate(t); // reflect to UI
				break;
			}
		}

		let info = 'Library contains:';
		for (let name of Object.keys(library.templates).sort()) {
			info += '\n   ' + name;
		}
		console.log(info);
	}
	
	// import a default body first
	// {
	// 	console.log(`Fetching body...`);
	// 	const request = await fetch('patterns/cube-3x3.body');
	// 	// const request = await fetch('example.body');
	// 	const arrayBuffer = await request.arrayBuffer();
	// 	console.log(`  got ${arrayBuffer.byteLength} bytes.`);

	// 	window.body = sv.Body.fromArrayBuffer(arrayBuffer, library);
	// 	regenerateCode();
	// 	checkGlobalCellCorrectness() 
	// }

	{
		console.log(`Loading textures...`)
		// Load texture
		window.arrowTexture = loadTexture(gl, "images/arrow.png");
		// Flip image pixels into the bottom-to-top order that WebGL expects.
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

	}

	bodyDirty();
	cursorDirty();
	resetCamera();
	requestRedraw();
}

init();

// global variables skCAD
let lastLoadedSTL = null;
let indicateLoopMode = false;
let selectedLoopIndex = 0;

// voxelize loaded STL mesh
document.getElementById("voxelize").addEventListener("click", async function() {
  // If no STL file is loaded, show an alert
  if (!lastLoadedSTL) {
    alert("Load an STL file.");
    return;
  }

  try {
    const template = library.getTemplateByLongname("unlabeled.right.alt");
    if (!template) throw new Error("Template 'unlabeled.right.alt' not loaded.");

    const templateVertices = template.vertices;
    const dx = Math.abs(templateVertices[4][0] - templateVertices[0][0]);
    const dy = Math.abs(templateVertices[2][1] - templateVertices[0][1]);
    const dz = Math.abs(templateVertices[1][2] - templateVertices[0][2]);

	// while voxelization is in progress, show a message
    STATUS_LINE.innerText = "Voxelizing...";
    
	// delay to allow UI to update
    await new Promise(resolve => setTimeout(resolve, 10));
    
	// run the voxelization process
    const bodyFromSTL = await sv.Body.fromSTL(lastLoadedSTL, library, [dx, dy, dz]);
    
    if (!bodyFromSTL || bodyFromSTL.cells.length === 0) {
      throw new Error("No cells generated.");
    }

	// swithch to the new body
    window.body = bodyFromSTL;
    
	// make the stl mesh invisible
    cleanupGLMesh();
    
	// update the view
    bodyDirty();
    cursorDirty();
    // resetCamera();
    // requestRedraw();
    
    // complete message
    STATUS_LINE.innerText = `Voxelization complete: ${bodyFromSTL.cells.length} cells created`;
  } catch (err) {
	console.error("Voxelization failed:", err);
    STATUS_LINE.innerText = "Voxelization failed: " + err.message;
  }
});


// load stl -> draw the stl mesh
function cameraProjectionMatrix() {
  const fovy = camera.fovy * Math.PI / 180.0;
  const aspect = camera.aspect;
  const near = 0.01;
  const far = 1000.0;

  const f = 1.0 / Math.tan(fovy / 2);
  const nf = 1 / (near - far);

  return new Float32Array([
    f / aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far + near) * nf, -1,
    0, 0, (2 * far * near) * nf, 0
  ]);
}
window.cameraProjectionMatrix = cameraProjectionMatrix;

function cameraViewMatrix() {
  const eye = camera.computeAt();
  const target = camera.target;
  const up = camera.computeUp();
  return lookAt(eye, target, up);
}
window.cameraViewMatrix = cameraViewMatrix;

import { setupGLMeshFromSTL, drawGLMesh, cleanupGLMesh} from './code/draw-stl.mjs';
const stlInput = document.getElementById("load-stl");
stlInput.addEventListener("change", function (evt) {
  const file = evt.target.files[0];
  if (!file) return;

  // set the filename to show later
  setFilename(file.name);

  // clear existing body
  window.body = new sv.Body();
  bodyDirty();
  cursorDirty();

  const reader = new FileReader();
  reader.onload = function (e) {
    const arrayBuffer = e.target.result;
    
	// save the loaded STL data to a global variable
    lastLoadedSTL = arrayBuffer;
    
    // if a mesh is already loaded, clear it
    if (window._meshData) {
      cleanupGLMesh();
    }

    // show the loaded STL mesh
    setupGLMeshFromSTL(arrayBuffer);
    console.log("STL file loaded:", file.name);
    
    // reset the camera and redraw to show the new mesh
    resetCamera();
    requestRedraw();
  };
  reader.readAsArrayBuffer(file);
});

// Indicate Loop mode toggle
document.getElementById("indicate-loop").addEventListener('click', function() {
    indicateLoopMode = !indicateLoopMode;
    
    if (indicateLoopMode) {
        this.textContent = "Indicate Loop";
        // Reset selectedLoopIndex when entering mode
        selectedLoopIndex = 0;
        updateLoopIndication();
    } else {
        this.textContent = "Indicate Loop";
        // Reset all yarn colors to default when exiting mode
        resetAllYarnColors();
    }
    bodyDirty();
    requestRedraw();
});


// auto convert cells
function autoConvertCells() {
    // determine path (cell order)
	determinePath();
    
	// Add null cells for "add another row in first layer" rule
    addUnlabeledCellsBetweenLayers();

    // convert cells to appropriate knit cells along the path
    convertCellsAlongPath();

	// add drop cells
    addDropCells();

	// add bind-off
	addBindOff();

	// connect within rows
	connectWithinRows();

	// add yarn-next-row cells
	// needs to be before connectBetweenLayers for firstRowHasBottomConnection (-l1 protruding)
	connectBetweenRows();

	// add loop-next-layer cells
	// needs to be before convertToIncreaseCells for increase
	// needs to be before convertToDecreaseCells for decrease at layer transition
	connectBetweenLayers();

	// convert cells to decrease cells 
	convertToDecreaseCells();

	// convert cells to increase cells
	convertToIncreaseCells();

	// add yarn-in and yarn-out
    addYarnInOut();

    bodyDirty();
    requestRedraw();
}

// determine path (cell order) based on coord
function determinePath() {
    const cells = body.cells;
    
    // calculate center coord of each cell
    let cellsWithCoords = cells.map(cell => {
        const center = gm.scale(1.0 / cell.vertices.length, 
            cell.vertices.reduce((acc, v) => gm.add(acc, v), gm.vec3(0,0,0)));
        return { cell, x: center[0], y: center[1], z: center[2] };
    });
    
	// filter cells with knit/null templates
    cellsWithCoords = cellsWithCoords.filter(item => 
        item.cell.template.longname.includes("knit") || 
        item.cell.template.longname.includes("unlabeled") ||
		item.cell.template.longname.includes("bind-off") ||
		item.cell.template.longname.includes("loop-to-layer")
    );
    
    // return [] if no knit templates found
    if (cellsWithCoords.length === 0) {
        return [];
    }
    
    // group cells based on z coord (= layer)
    const layers = {};
    cellsWithCoords.forEach(item => {
        const z = Math.round(item.z * 10) / 10; // to ignore errors
        if (!layers[z]) layers[z] = [];
        layers[z].push(item);
    });
    
    // sort layers
    const sortedLayers = Object.keys(layers).sort((a, b) => parseFloat(a) - parseFloat(b));
    
    const path = [];
    let lastCell = null;
    let rowDirection = 1; // 1: left to right, -1: right to left
    
    sortedLayers.forEach((z, layerIndex) => {
        const layer = layers[z];
        
        if (layerIndex % 2 === 0) {
            // even layers: ascending order by y coord
            layer.sort((a, b) => a.y - b.y);
        } else {
            // odd layers: descending order by y coord
            layer.sort((a, b) => b.y - a.y);
        }
        
        // sort each row by x coord
        const rows = groupByRow(layer);

		// handle row increase at layer transition
		// determine row direction based on first row first cell's bottom connection
		if (layerIndex !== 0) { // not for the first layer
			let firstRowHasBottomConnection = false;
			for (let fi = 0; fi < rows[0][0].cell.template.faces.length; fi++) {
				if (rows[0][0].cell.template.faces[fi].type === "-L1" && 
					rows[0][0].cell.connections[fi] !== null) {
					firstRowHasBottomConnection = true;
					break;
				}
			}
		}

		// iterate through each row
        rows.forEach((row, rowIndex) => {
			if (layerIndex % 2 === 0) {
				if (rowDirection > 0) {
					row.sort((a, b) => a.x - b.x);
				} else {
					row.sort((a, b) => b.x - a.x);
				}
			} else {
				if (rowDirection > 0) {
					row.sort((a, b) => b.x - a.x);
				} else {
					row.sort((a, b) => a.x - b.x);
				}
			}
            
            row.forEach(item => {
				// Calculate column index based on x coordinate
                const columnIndex = Math.round(item.x * 10) / 10;

                path.push({
                    cell: item.cell,
					cellID: body.cells.indexOf(item.cell),
                    layerIndex,
                    rowIndex,
					columnIndex,
                    direction: rowDirection > 0 ? "right" : "left",
                    isFirstInRow: row[0] === item,
                    isLastInRow: row[row.length - 1] === item,
                    isFirstLayer: layerIndex === 0,
                    isLastLayer: layerIndex === sortedLayers.length - 1
                });
            });
            
            // next row will be in opposite direction
            // except for transition from last row to first row of next layer
            if (rowIndex < rows.length - 1) {
				rowDirection *= -1;
            }
        });
    });
	
	window.path = path; // save path to global variable. now using for indicate loop mode too
    return path;
}

// row grouping
function groupByRow(cells) {
    const rows = {};
    cells.forEach(cell => {
        const y = Math.round(cell.y * 10) / 10;
        if (!rows[y]) rows[y] = [];
        rows[y].push(cell);
    });
    return Object.values(rows);
}

// convert cells
function convertCellsAlongPath() {
    // Get the path information
    const path = window.path || determinePath();
    if (path.length === 0) return;
    
    // convert each cell to the appropriate knit cell
    let convertedCount = 0;
    path.forEach((item, index) => {
        const template = selectKnitTemplate(item);
        if (template) {
            replaceCell(item.cell, template);
            convertedCount++;
        } else {
            console.error(`Failed to get template for cell ${index + 1}`, item);
        }
    });
}

// select appropriate knit template
function selectKnitTemplate(pathItem) {
    const { cell, direction } = pathItem;
    
    // check connections for -L1 face (bottom)
    let hasBottomConnection = false;
    for (let fi = 0; fi < cell.template.faces.length; ++fi) {
        if (cell.template.faces[fi].type === "-L1" && cell.connections[fi] !== null) {
            hasBottomConnection = true;
            break;
        }
    }
    
    // check connections for +L1 face (top)
    let hasTopConnection = false;
    for (let fi = 0; fi < cell.template.faces.length; ++fi) {
        if (cell.template.faces[fi].type === "+L1" && cell.connections[fi] !== null) {
            hasTopConnection = true;
            break;
        }
    }
    
    let templateName;

	// conditions when not using under-empty and over-under-empty templates (using drop blocks)
    if (!hasBottomConnection) {
        // no bottom connection
        templateName = direction === "right" ? "knit.over-empty.right.alt" : "knit.over-empty.left.alt";
    } else {
        // bottom connection exists
        templateName = direction === "right" ? "knit.right.alt" : "knit.left.alt";
    }
    
    const template = window.library.getTemplateByLongname(templateName);
    
    if (!template) {
        console.error(`Template "${templateName}" not found in library`);
    }
	
    return template;
}

function addNewCellToTarget(targetCell, targetCellFaceType, newTemplateName, newTemplateFaceType) {
    // Validate arguments
    if (!targetCell) {
        console.error("Invalid targetCell");
        return null;
    }
    
    // Get new template
    const newTemplate = library.getTemplateByLongname(newTemplateName);
    if (!newTemplate) {
        console.error(`Template "${newTemplateName}" not found`);
        return null;
    }
    
    // Find target face index
    const targetFaceIndex = getFaceIndex(targetCell, targetCellFaceType);
    if (targetFaceIndex === -1) {
        console.error(`Target face type "${targetCellFaceType}" not found in target cell`);
        return null;
    }
    
    // Check if target face is already connected
    if (targetCell.connections[targetFaceIndex] !== null) {
        console.error(`Target face type "${targetCellFaceType}" is already connected`);
        return null;
    }
    
    // Validate new template has the specified face type
    const newTemplateFaceIndex = getFaceIndex(newTemplate, newTemplateFaceType);
    if (newTemplateFaceIndex === -1) {
        console.error(`New template face type "${newTemplateFaceType}" not found in template "${newTemplateName}"`);
        return null;
    }
    
    // Position new cell using checkTemplateCompatible (automatically sets up connections)
    const newCell = checkTemplateCompatible(targetCell, targetFaceIndex, newTemplate);
    
    if (!newCell) {
        console.error(`Could not position template "${newTemplateName}" compatible with target cell`);
        return null;
    }
    
    // Add new cell to body
    body.cells.push(newCell);

    // Update UI
    bodyDirty();
    
    return newCell;
}

function replaceCell(oldCell, newTemplate) {
    const index = body.cells.indexOf(oldCell);
    if (index === -1) {
        console.error("Old cell not found in body.cells");
        return;
    }

    const newCell = sv.Cell.fromTemplate(newTemplate, oldCell.xform);
    
    // determine the direction (use the parameter newDirection for new cell)
    const oldDirection = getTemplateDirection(oldCell.template.longname);
	const newDirection = getTemplateDirection(newTemplate.longname);
    const isDirectionChanged = (oldDirection !== newDirection);
    
    // store all existing connections before clearing them
    const existingConnections = [];
    oldCell.connections.forEach((conn, fi) => {
        if (conn !== null) {
            existingConnections.push({
                oldFaceIndex: fi,
                oldFaceType: oldCell.template.faces[fi].type,
                connectedCell: conn.cell,
                connectedFace: conn.face
            });
            
            // clear the connection from the other side first
            conn.cell.connections[conn.face] = null;
        }
    });
    
    // replace the cell in the body
    body.cells[index] = newCell;

	// Update path if it exists
    if (window.path) {
        for (let pathItem of window.path) {
            if (pathItem.cell === oldCell) {
                pathItem.cell = newCell;
                // cellID should remain the same since it's the same position in body.cells
            }
        }
    }
    
    // restore connections with direction consideration
    existingConnections.forEach(connInfo => {
        let targetFaceType = connInfo.oldFaceType;
        
        // if the direction has changed, flip the face type
		// (e.g., +y1 becomes -y1, -y1 becomes +y1)
        if (isDirectionChanged) {
            targetFaceType = getFlippedFaceType(connInfo.oldFaceType);
        }
        
        // find matching face type in new template
        let newFaceIndex = -1;
        for (let fi = 0; fi < newCell.template.faces.length; fi++) {
            if (newCell.template.faces[fi].type === targetFaceType && 
                newCell.connections[fi] === null) {
                newFaceIndex = fi;
                break;
            }
        }
        
        if (newFaceIndex !== -1) {
            // restore connection
            newCell.connections[newFaceIndex] = {
                cell: connInfo.connectedCell,
                face: connInfo.connectedFace
            };
            connInfo.connectedCell.connections[connInfo.connectedFace] = {
                cell: newCell,
                face: newFaceIndex
            };
        } else {
            // console.warn(`Could not restore connection for face type: ${connInfo.oldFaceType} -> ${targetFaceType}`);
        }
    });
    
	// auto connect with neighbors
	// for cells replaced with ones having different face type configuration (e.g., decrease)
	autoConnectWithNeighbors(newCell);

    // clear any existing drawing info
    if (oldCell.centers) delete oldCell.centers;
    if (oldCell.ports) delete oldCell.ports;
    if (oldCell.center) delete oldCell.center;
    
    // mark new cell as dirty to ensure proper rendering
    newCell.dirty = true;
}

// auto connect with neighbors after replaceCell
function autoConnectWithNeighbors(targetCell) {
    // Get all unconnected faces of the target cell
    const unconnectedFaces = [];
    for (let fi = 0; fi < targetCell.template.faces.length; fi++) {
        if (targetCell.connections[fi] === null) {
            unconnectedFaces.push({
                index: fi,
                type: targetCell.template.faces[fi].type
            });
        }
    }
    
    if (unconnectedFaces.length === 0) return;
    
    // Check all other cells for potential connections
    body.cells.forEach(otherCell => {
        if (otherCell === targetCell) return;
        
        // Calculate distance between cell centers
        const targetCenter = getCellCenter(targetCell);
        const otherCenter = getCellCenter(otherCell);
        const distance = Math.sqrt(
            Math.pow(targetCenter.x - otherCenter.x, 2) +
            Math.pow(targetCenter.y - otherCenter.y, 2) +
            Math.pow(targetCenter.z - otherCenter.z, 2)
        );
        
        // Only consider nearby cells (within 2 cell units)
        const maxDistance = getTemplateLength(targetCell.template, 'X') * 2;
        if (distance > maxDistance) return;
        
        // Try to connect compatible faces
        for (let targetFace of unconnectedFaces) {
            if (targetCell.connections[targetFace.index] !== null) continue; // Skip if already connected
            
            for (let otherFi = 0; otherFi < otherCell.template.faces.length; otherFi++) {
                if (otherCell.connections[otherFi] !== null) continue; // Skip if already connected
                
                const otherFaceType = otherCell.template.faces[otherFi].type;
                
                // Check if faces can connect
                if (sv.canConnectFaces(targetCell.template.faces[targetFace.index], otherCell.template.faces[otherFi])) {
                    // Calculate face centers to verify proximity
                    const targetFaceCenter = calculateFaceCenter(targetCell, targetFace.index);
                    const otherFaceCenter = calculateFaceCenter(otherCell, otherFi);
                    const faceDistance = Math.sqrt(
                        Math.pow(targetFaceCenter.x - otherFaceCenter.x, 2) +
                        Math.pow(targetFaceCenter.y - otherFaceCenter.y, 2) +
                        Math.pow(targetFaceCenter.z - otherFaceCenter.z, 2)
                    );
                    
                    // Connect if faces are very close (within 0.2 units)
                    if (faceDistance < 0.2) {
                        targetCell.connections[targetFace.index] = {
                            cell: otherCell,
                            face: otherFi
                        };
                        otherCell.connections[otherFi] = {
                            cell: targetCell,
                            face: targetFace.index
                        };
                        
                        break; // Move to next target face
                    }
                }
            }
        }
    });
}

// helper function to calculate face center
function calculateFaceCenter(cell, faceIndex) {
    const face = cell.template.faces[faceIndex];
    let center = gm.vec3(0.0);
    for (let vi of face.indices) {
        center = gm.add(center, cell.vertices[vi]);
    }
    center = gm.scale(1.0 / face.indices.length, center);
    return {
        x: center[0],
        y: center[1], 
        z: center[2]
    };
}

// helper function to determine the direction of a template
function getTemplateDirection(templateLongname) {
    if (templateLongname.includes(".right")) {
        return "right";
    } else if (templateLongname.includes(".left")) {
        return "left";
    } else {
        return "neutral";
    }
}

// type mapping for flipping face types
function getFlippedFaceType(faceType) {
    const flippingMap = {
        "+y1": "-y1",
        "-y1": "+y1",
		// don't flip L1/l1 faces (up/down and front/back relationships remain the same)
        "+L1": "+L1",
        "-L1": "-L1",
        "+l1": "+l1",
        "-l1": "-l1",
        "x": "x"
    };
    
    return flippingMap[faceType] || faceType;
}		

// Function to add yarn-out (uses existing functions)
function addYarnOut(lastPathItem) {
    const { cell, direction } = lastPathItem;
    
    // Get the yarn-out template
    const yarnOutTemplate = library.getTemplateByLongname(
        direction === "right" ? "yarn-out.right" : "yarn-out.left"
    );
    
    if (!yarnOutTemplate) {
        console.error("yarn-out template not found");
        return;
    }
    
    // Find the +y1 face (yarn-out has a -y1 face and connects to the cell's +y1 face)
    for (let faceIndex = 0; faceIndex < cell.template.faces.length; faceIndex++) {
        if (cell.template.faces[faceIndex].type === "+y1" && !cell.connections[faceIndex]) {
            // Use checkTemplateCompatible to check if placement is possible
            const preview = checkTemplateCompatible(cell, faceIndex, yarnOutTemplate);
            if (preview) {
                body.cells.push(preview);
                return;
            }
        }
    }
    console.error("Cannot connect yarn-out to cell");
}

// Function to add drop cells
function addDropCells() {
    const dropTemplate = library.getTemplateByLongname("drop");
    
    if (!dropTemplate) {
        console.error("drop template not found");
        return;
    }
    
    body.cells.forEach(cell => {
        // Find +L1 face (top face)
        const topFaceIndex = getFaceIndex(cell, "+L1");
        
        if (topFaceIndex !== -1 && !cell.connections[topFaceIndex]) {
            const dropCell = checkTemplateCompatible(cell, topFaceIndex, dropTemplate);
            if (dropCell) {
                // Find the -L1 face in the drop cell (bottom face)
                const dropCellBottomFace = getFaceIndex(dropCell, "-L1");
                
                if (dropCellBottomFace !== -1) {
                    // Establish the connection
                    dropCell.connections[dropCellBottomFace] = {
                        cell: cell,
                        face: topFaceIndex
                    };
                    cell.connections[topFaceIndex] = {
                        cell: dropCell,
                        face: dropCellBottomFace
                    };
                    
                    body.cells.push(dropCell);
                }
            }
        }
    });
    
    bodyDirty();
    requestRedraw();
}

// Function to add cast-on and bind-off 
function addCastOnBindOff() {
    const path = determinePath();
    if (path.length === 0) return;
    
    // Add cast-on to the first row of the first layer
    const firstRowCells = path.filter(item => 
        item.isFirstLayer && item.rowIndex === 0
    );
    
    firstRowCells.forEach(item => {
        const castOnTemplate = library.getTemplateByLongname(
            item.direction === "right" ? "cast-on.right" : "cast-on.left"
        );
        
        if (castOnTemplate) {
            // Connect to the -l1 face
            for (let face = 0; face < item.cell.template.faces.length; face++) {
                if (item.cell.template.faces[face].type === "-l1" && 
                    !item.cell.connections[face]) {
                    
                    const castOn = checkTemplateCompatible(
                        item.cell, face, castOnTemplate
                    );
                    if (castOn) {
                        body.cells.push(castOn);
                    }
                }
            }
        }
    });
    
    // Add bind-off to the last row of the last layer
    const lastLayerLastRow = path.filter(item => 
        item.isLastLayer && 
        path.filter(p => p.layerIndex === item.layerIndex && 
                        p.rowIndex > item.rowIndex).length === 0
    );
    
    lastLayerLastRow.forEach(item => {
        const bindOffTemplate = library.getTemplateByLongname(
            `bind-off-through-${item.direction === "right" ? "down" : "up"}.${item.direction}`
        );
        
        if (bindOffTemplate) {
			// Connect to the +l1 face
            for (let face = 0; face < item.cell.template.faces.length; face++) {
                if (item.cell.template.faces[face].type === "+l1" && 
                    !item.cell.connections[face]) {
                    
                    const bindOff = checkTemplateCompatible(
                        item.cell, face, bindOffTemplate
                    );
                    if (bindOff) {
                        body.cells.push(bindOff);
                    }
                }
            }
        }
    });
}

// convert cells back to null cells
function convertCellsToNullByDirection() {
    for (const cell of body.cells.slice()) {
        // determine direction from template name
        const templateName = cell.template.longname;
        
        if (templateName.includes("knit") && templateName.includes(".right")) {
            const newTemplate = library.getTemplateByLongname("unlabeled.right.alt");
            if (newTemplate && !templateName.startsWith("unlabeled.")) {
                replaceCell(cell, newTemplate);
            }
        } else if (templateName.includes("knit") && templateName.includes(".left")) {
            const newTemplate = library.getTemplateByLongname("unlabeled.left.alt");
            if (newTemplate && !templateName.startsWith("unlabeled.")) {
                replaceCell(cell, newTemplate);
            }
        } else if (templateName.includes("loop-to-layer")) {
            // Find -l1 face and check connected cell's direction
            let backFaceIndex = -1;
            for (let fi = 0; fi < cell.template.faces.length; fi++) {
                if (cell.template.faces[fi].type === "-l1") {
                    backFaceIndex = fi;
                    break;
                }
            }

            if (backFaceIndex !== -1 && cell.connections[backFaceIndex]) {
                const connectedCell = cell.connections[backFaceIndex].cell;
                const connectedTemplateName = connectedCell.template.longname;
                
                if (connectedTemplateName.includes(".left")) {
                    const newTemplate = library.getTemplateByLongname("unlabeled.right.alt");
                    if (newTemplate) {
                        replaceCell(cell, newTemplate);
                    }
                } else if (connectedTemplateName.includes(".right")) {
                    const newTemplate = library.getTemplateByLongname("unlabeled.left.alt");
                    if (newTemplate) {
                        replaceCell(cell, newTemplate);
                    }
                }
            }
        }

		else {
			// delete cell
			const index = body.cells.indexOf(cell);
            if (index !== -1) {
                unsafeDeleteCell(index);
            }
		}
    }
    bodyDirty();
    requestRedraw();
}


// Helper function to get the face index of a specific type (including connected faces)
function getFaceIndex(cellOrTemplate, faceType) {
    const faces = cellOrTemplate.template ? cellOrTemplate.template.faces : cellOrTemplate.faces;
    for (let fi = 0; fi < faces.length; fi++) {
        if (faces[fi].type === faceType) {
            return fi;
        }
    }
    return -1;
}

// connect +l1 and -l1 faces between adjacent layers using loop blocks
function connectBetweenLayers() {
    // Get the path information
    const path = window.path || determinePath();
    if (path.length === 0) return;
    
    // calculate center coord of each cell and group by column and layer
    const cellsWithCoords = body.cells.map(cell => {
        const center = gm.scale(1.0 / cell.vertices.length, 
            cell.vertices.reduce((acc, v) => gm.add(acc, v), gm.vec3(0,0,0)));
        return { 
            cell, 
            x: Math.round(center[0] * 10) / 10, // round to avoid floating point errors
            y: Math.round(center[1] * 10) / 10,
            z: Math.round(center[2] * 10) / 10 
        };
    });
    
    // group cells by column (x coordinate) and layer (z coordinate)
    const columns = {};
    cellsWithCoords.forEach(item => {
        const columnKey = item.x.toString();
        if (!columns[columnKey]) columns[columnKey] = {};
        
        const layerKey = item.z.toString();
        if (!columns[columnKey][layerKey]) columns[columnKey][layerKey] = [];
        
        columns[columnKey][layerKey].push(item);
    });
    
    let connectionsCount = 0;
    
    // Get unique layer indices and sort them
    const layerIndices = [...new Set(path.map(item => item.layerIndex))].sort((a, b) => a - b);
    
    // iterate through adjacent layers
    for (let layerIdx = 0; layerIdx < layerIndices.length - 1; layerIdx++) {
        const currentLayerIndex = layerIndices[layerIdx];
        const nextLayerIndex = layerIndices[layerIdx + 1];
        
        // Find the minimum row index in next layer
        const nextLayerItems = path.filter(item => item.layerIndex === nextLayerIndex);
        if (nextLayerItems.length === 0) continue;
        
        const minRowIndex = Math.min(...nextLayerItems.map(item => item.rowIndex));
        
        // Get cells in the first row of next layer
        const firstRowCells = nextLayerItems.filter(item => item.rowIndex === minRowIndex);
        
        if (firstRowCells.length === 0) continue;
        
        // Get all unique columns that have cells in the first row of next layer
        const targetColumns = [...new Set(firstRowCells.map(cell => 
            Math.round(getCellCenter(cell.cell).x * 10) / 10
        ))];
        
        // Process each column that has cells in the first row of next layer
        targetColumns.forEach(targetColumnX => {
            const targetColumnKey = targetColumnX.toString();
            const column = columns[targetColumnKey];
            if (!column) return;
            
            const currentLayerItems = path.filter(item => item.layerIndex === currentLayerIndex);
            if (currentLayerItems.length === 0) return;
            
            const currentLayerKey = Math.round(getCellCenter(currentLayerItems[0].cell).z * 10) / 10;
            const nextLayerKey = Math.round(getCellCenter(firstRowCells[0].cell).z * 10) / 10;
            
            const currentLayerCells = column[currentLayerKey.toString()];
            const nextLayerCells = column[nextLayerKey.toString()];
            
            if (!currentLayerCells || !nextLayerCells) return;

            // find cells with unconnected +l1 faces in current layer
            const currentLayerCellsWithFrontUnconnected = currentLayerCells.filter(item => {
                for (let fi = 0; fi < item.cell.template.faces.length; fi++) {
                    if (item.cell.template.faces[fi].type === "+l1" && 
                        item.cell.connections[fi] === null) {
                        return true;
                    }
                }
                return false;
            });

            // Get only the cell with the maximum rowIndex from currentLayerCellsWithFrontUnconnected
            let edgeItem = null;
            if (currentLayerCellsWithFrontUnconnected.length > 0) {
                edgeItem = currentLayerCellsWithFrontUnconnected.reduce((maxItem, currentItem) => {
                    // Get rowIndex from path for comparison
                    const currentRowIndex = path.find(pathItem => pathItem.cell === currentItem.cell)?.rowIndex || -1;
                    const maxRowIndex = path.find(pathItem => pathItem.cell === maxItem.cell)?.rowIndex || -1;
                    return currentRowIndex > maxRowIndex ? currentItem : maxItem;
                });
            }
            
            // find cells with unconnected -l1 faces in next layer (specifically in first row)
            const nextLayerCellsWithBackUnconnected = nextLayerCells.filter(item => {
                // Check if this cell is in the first row of next layer
                const cellPathItem = path.find(pathItem => pathItem.cell === item.cell);
                if (!cellPathItem || cellPathItem.rowIndex !== minRowIndex) return false;
                
                for (let fi = 0; fi < item.cell.template.faces.length; fi++) {
                    if (item.cell.template.faces[fi].type === "-l1" && 
                        item.cell.connections[fi] === null) {
                        return true;
                    }
                }
                return false;
            });
            
            // process only the edge item with maximum rowIndex
            if (edgeItem) {
                const currentItem = edgeItem; // use the edge item with maximum rowIndex
                const currentL1Face = getFaceIndex(currentItem.cell, "+l1");
                if (currentL1Face === -1) return;
                
                // check if this +l1 face is "protruding" (no cell above it)
                const isPlusL1Protruding = !hasCellAbove(currentItem.cell);
                
                // find closest -l1 face in next layer
                const closestMinusL1 = findClosestCellWithUnconnectedFace(currentItem, nextLayerCellsWithBackUnconnected, "-l1");
                if (!closestMinusL1) return;
                
                const minusL1Face = getFaceIndex(closestMinusL1.cell, "-l1");
                if (minusL1Face === -1) return;
                
                // check if this -l1 face is "protruding" (no cell below it)
                const isMinusL1Protruding = !hasCellBelow(closestMinusL1.cell);
                
                // calculate Y distance in cell units
                const yDistance = Math.abs(currentItem.y - closestMinusL1.y) / getTemplateLength(currentItem.cell.template, 'Y');
                const cellDistance = Math.round(yDistance);
                
                if (yDistance < 0.1) {
                    // Case 3: Same Y coordinate - direct vertical connection
                    addLoopNextLayerForVerticalConnection(currentItem.cell, currentL1Face, closestMinusL1.cell, minusL1Face);
                    connectionsCount++;
                } else if (isPlusL1Protruding && !isMinusL1Protruding) {
                    // Case 1: +l1 face is protruding
                    addLoopStructureForPlusL1Protruding(currentItem.cell, currentL1Face, closestMinusL1.cell, minusL1Face, cellDistance);
                    connectionsCount++;
                } else if (isMinusL1Protruding && !isPlusL1Protruding) {
                    // Case 2: -l1 face is protruding  
					addLoopStructureForMinusL1Protruding(currentItem.cell, currentL1Face, closestMinusL1.cell, minusL1Face, cellDistance);
                    // find closest unconnected -L1 face in next layer

                    connectionsCount++;
                }
            }
        });
    }
    
    if (connectionsCount > 0) {
        bodyDirty();
        requestRedraw();
    }
    
    return;
}

// Connect +y1 and -y1 faces between adjacent rows using yarn-next-row and yarn-next-column blocks
function connectBetweenRows() {
    // Get the path information to determine row directions
    const path = determinePath();

    if (path.length === 0) {
        return 0;
    }
    
    // Create a map from cell to path info for quick lookup
    const cellToPathInfo = new Map();
    path.forEach(pathItem => {
        cellToPathInfo.set(pathItem.cell, pathItem);
    });
    
    // Calculate center coord of each cell and group by layer and row
    const cellsWithCoords = body.cells.map(cell => {
        const center = gm.scale(1.0 / cell.vertices.length, 
            cell.vertices.reduce((acc, v) => gm.add(acc, v), gm.vec3(0,0,0)));
        return { 
            cell, 
            x: Math.round(center[0] * 10) / 10, // round to avoid floating point errors
            y: Math.round(center[1] * 10) / 10,
            z: Math.round(center[2] * 10) / 10 
        };
    });
    
    // Group cells by layer (z coordinate) and row (y coordinate)
    const layers = {};
    cellsWithCoords.forEach(item => {
        const layerKey = item.z.toString();
        if (!layers[layerKey]) layers[layerKey] = {};
        
        const rowKey = item.y.toString();
        if (!layers[layerKey][rowKey]) layers[layerKey][rowKey] = [];
        
        layers[layerKey][rowKey].push(item);
    });
    
    let connectionsCount = 0;
    
    
    // Process connections following the path order
    for (let i = 0; i < path.length - 1; i++) {
        const currentPathItem = path[i];
        const nextPathItem = path[i + 1];
        
        // Only process row transitions (same layer, different row)
        if (currentPathItem.layerIndex !== nextPathItem.layerIndex) {
            continue; // Skip layer transitions
        }
        
        if (currentPathItem.rowIndex === nextPathItem.rowIndex) {
            continue; // Skip within-row connections
        }
        
        const currentCell = currentPathItem.cell;
        const nextCell = nextPathItem.cell;
        
        // Find +y1 face in current cell
        const currentY1Face = getCurrentY1Face(currentCell, "+y1");
        if (currentY1Face === -1) {
            continue;
        }
        // Find -y1 face in next cell
        const nextY1Face = getCurrentY1Face(nextCell, "-y1");
        if (nextY1Face === -1) {
            continue;
        }
        
        const currentRowDirection = currentPathItem.direction;

        // Check if this is a protruding case or direct connection
        const isPlusY1Protruding = !hasCellToRight(currentCell);
        const isMinusY1Protruding = !hasCellToLeft(nextCell);

		// Calculate X distance in cell units
		const currentItem = cellsWithCoords.find(item => item.cell === currentCell);
		const nextItem = cellsWithCoords.find(item => item.cell === nextCell);
		const xDistance = Math.abs(currentItem.x - nextItem.x) / getTemplateLength(currentItem.cell.template, 'X');
		const cellDistance = Math.round(xDistance);
        
        if (xDistance < 0.1) {
            // Case 3: Same X coordinate - direct row-to-row connection
            addYarnNextRowForDirectConnection(currentCell, currentY1Face, nextCell, nextY1Face, currentRowDirection);
            connectionsCount++;
        } else if (isPlusY1Protruding && !isMinusY1Protruding) {
            // Case 1: +y1 face is protruding
			addYarnStructureForPlusY1Protruding(currentCell, currentY1Face, nextCell, nextY1Face, cellDistance, currentRowDirection);
            connectionsCount++;
        } else if (isMinusY1Protruding && !isPlusY1Protruding) {
            // Case 2: -y1 face is protruding  
            addYarnStructureForMinusY1Protruding(currentCell, currentY1Face, nextCell, nextY1Face, cellDistance, currentRowDirection);
			connectionsCount++;
        } else {
            addYarnNextRowForDirectConnection(currentCell, currentY1Face, nextCell, nextY1Face, currentRowDirection);
            connectionsCount++;
        }
    }
        
    if (connectionsCount > 0) {
        bodyDirty();
        requestRedraw();
    }
    
    return;
}

// Helper function to caculate the template x/y/z length for xDistance/cellDistance
function getTemplateLength(template, axis) {
    let min = Infinity;
    let max = -Infinity;
    let idx = axis === 'X' ? 0 : axis === 'Y' ? 1 : 2;
    for (const v of template.vertices) {
        if (v[idx] < min) min = v[idx];
        if (v[idx] > max) max = v[idx];
    }
    return Math.abs(max - min);
}

// Helper function to get the face index of a specific l1 type (only unconnected)
function getCurrentL1Face(cell, faceType) {
    for (let fi = 0; fi < cell.template.faces.length; fi++) {
        if (cell.template.faces[fi].type === faceType && 
            cell.connections[fi] === null) {
            return fi;
        }
    }
    return -1;
}

// Helper function to get the face index of a specific y1 type (only unconnected)
function getCurrentY1Face(cell, faceType) {
    for (let fi = 0; fi < cell.template.faces.length; fi++) {
        if (cell.template.faces[fi].type === faceType && 
            cell.connections[fi] === null) {
            return fi;
        }
    }
    return -1;
}

// Helper function to find the closest l1 face in a list of cells
function findClosestCellWithUnconnectedFace(targetItem, candidateCells, faceType) {
    let closest = null;
    let minDistance = Infinity;
    
    candidateCells.forEach(candidate => {
        const distance = Math.abs(targetItem.y - candidate.y);
        if (distance < minDistance) {
            // const faceIndex = getCurrentL1Face(candidate.cell, faceType);
			const faceIndex = getFaceIndex(candidate.cell, faceType);
            if (faceIndex !== -1) {
                minDistance = distance;
                closest = candidate;
            }
        }
    });
    
    return closest;
}

// Case 3: Same Y coordinate - add loop-next-layer for vertical connection
function addLoopNextLayerForVerticalConnection(currentCell, currentFace, nextCell, nextFace) {
    const loopNextLayerTemplate = library.getTemplateByLongname("loop-next-layer");
    if (!loopNextLayerTemplate) {
        console.error("loop-next-layer template not found");
        return;
    }
    
    let loopNextLayer = checkTemplateCompatible(currentCell, currentFace, loopNextLayerTemplate);
    let connectFromCurrent = true;
    
    if (!loopNextLayer) {
        loopNextLayer = checkTemplateCompatible(nextCell, nextFace, loopNextLayerTemplate);
        connectFromCurrent = false;
    }
    
    if (!loopNextLayer) {
        console.error("Could not position loop-next-layer properly");
        return;
    }
    
	// manually establish the connection
    if (connectFromCurrent) {
        // currentCell -> loopNextLayer -> nextCell
        const layerInputFace = findCompatibleFace(loopNextLayerTemplate, currentCell.template.faces[currentFace]);
        const layerOutputFace = findOutputFace(loopNextLayer);
        
        if (layerInputFace !== -1) {
            currentCell.connections[currentFace] = { cell: loopNextLayer, face: layerInputFace };
            loopNextLayer.connections[layerInputFace] = { cell: currentCell, face: currentFace };
        }
        
        if (layerOutputFace !== -1 && sv.canConnectFaces(loopNextLayer.template.faces[layerOutputFace], nextCell.template.faces[nextFace])) {
            nextCell.connections[nextFace] = { cell: loopNextLayer, face: layerOutputFace };
            loopNextLayer.connections[layerOutputFace] = { cell: nextCell, face: nextFace };
        }
    } else {
        // nextCell -> loopNextLayer -> currentCell
        const layerInputFace = findCompatibleFace(loopNextLayerTemplate, nextCell.template.faces[nextFace]);
        const layerOutputFace = findOutputFace(loopNextLayer);
        
        if (layerInputFace !== -1) {
            nextCell.connections[nextFace] = { cell: loopNextLayer, face: layerInputFace };
            loopNextLayer.connections[layerInputFace] = { cell: nextCell, face: nextFace };
        }
        
        if (layerOutputFace !== -1 && sv.canConnectFaces(loopNextLayer.template.faces[layerOutputFace], currentCell.template.faces[currentFace])) {
            currentCell.connections[currentFace] = { cell: loopNextLayer, face: layerOutputFace };
            loopNextLayer.connections[layerOutputFace] = { cell: currentCell, face: currentFace };
        }
    }
    
    body.cells.push(loopNextLayer);
}

// Case 1: +l1 face is protruding - add loop-next-row to next layer, then loop-next-layer
function addLoopStructureForPlusL1Protruding(currentCell, currentFace, nextCell, nextFace, cellDistance) { 
    const loopNextRowTemplate = library.getTemplateByLongname("loop-next-row");
    const loopNextLayerTemplate = library.getTemplateByLongname("loop-next-layer");
    
    if (!loopNextRowTemplate || !loopNextLayerTemplate) {
        console.error("Required templates not found");
        return;
    }

    // Case for +l1 protruding: start from upper layer (-l1 face) and create downward loop-next-row chain
    // nextCell(-l1) -> loop-next-row(+l1) -> loop-next-row(-l1) -> ... -> loop-next-layer(+l1) -> currentCell(+l1)
    
    const loopNextRows = [];
    let lastConnectedCell = nextCell;
    let lastConnectedFace = nextFace;
    
    for (let i = 0; i < cellDistance; i++) {    
        const loopNextRow = checkTemplateCompatible(lastConnectedCell, lastConnectedFace, loopNextRowTemplate);
        
        if (loopNextRow) {
            // Find connection face (connect +l1 face to -l1 face)
            const loopConnectFace = findCompatibleFace(loopNextRowTemplate, lastConnectedCell.template.faces[lastConnectedFace]);
            if (loopConnectFace !== -1) {
                lastConnectedCell.connections[lastConnectedFace] = { cell: loopNextRow, face: loopConnectFace };
                loopNextRow.connections[loopConnectFace] = { cell: lastConnectedCell, face: lastConnectedFace };
            }
            
            loopNextRows.push(loopNextRow);
            body.cells.push(loopNextRow);
            
            // Find -l1 face for next connection (pattern from +l1 face to -l1 face)
            const nextFaceForLoop = findInputFace(loopNextRow); // finde -l1 face
            if (nextFaceForLoop !== -1) {
                lastConnectedCell = loopNextRow;
                lastConnectedFace = nextFaceForLoop;
            } else {
                console.error(`No input face found on loop-next-row ${i + 1}`);
                break;
            }
        }
    }
    
    // Connect -l1 face of last loop-next-row with +l1 face of loop-next-layer
    if (loopNextRows.length > 0) {
        const lastLoop = loopNextRows[loopNextRows.length - 1];
        
        const loopNextLayer = checkTemplateCompatible(lastLoop, lastConnectedFace, loopNextLayerTemplate);
        
        if (loopNextLayer) {
            // lastLoop(-l1) <-> loopNextLayer(+l1)
            const layerConnectFace = findCompatibleFace(loopNextLayerTemplate, lastLoop.template.faces[lastConnectedFace]);
            if (layerConnectFace !== -1) {
                lastLoop.connections[lastConnectedFace] = { cell: loopNextLayer, face: layerConnectFace };
                loopNextLayer.connections[layerConnectFace] = { cell: lastLoop, face: lastConnectedFace };
            }
            
            // loopNextLayer(-l1) <-> currentCell(+l1)
            const layerOutputFace = findInputFace(loopNextLayer); // finde -l1 face
            if (layerOutputFace !== -1 && sv.canConnectFaces(loopNextLayer.template.faces[layerOutputFace], currentCell.template.faces[currentFace])) {
                currentCell.connections[currentFace] = { cell: loopNextLayer, face: layerOutputFace };
                loopNextLayer.connections[layerOutputFace] = { cell: currentCell, face: currentFace };
            }
            
            body.cells.push(loopNextLayer);
        }
    }
}

// Case 2: -l1 face is protruding - add loop-next-row to current layer, then loop-next-layer  
function addLoopStructureForMinusL1Protruding(currentCell, currentFace, nextCell, nextFace, cellDistance) {    
    const loopNextRowTemplate = library.getTemplateByLongname("loop-next-row");
    const loopNextLayerTemplate = library.getTemplateByLongname("loop-next-layer");
    
    if (!loopNextRowTemplate || !loopNextLayerTemplate) {
        console.error("Required templates not found");
        return;
    }
   
    // Create loop-next-row chain extending toward next cell
    const loopNextRows = [];
    let lastConnectedCell = currentCell;
    let lastConnectedFace = currentFace;
    
    for (let i = 0; i < cellDistance; i++) {      
        const loopNextRow = checkTemplateCompatible(lastConnectedCell, lastConnectedFace, loopNextRowTemplate);
        
        if (loopNextRow) {
            // Manually establish connection
            const loopConnectFace = findCompatibleFace(loopNextRowTemplate, lastConnectedCell.template.faces[lastConnectedFace]);
            if (loopConnectFace !== -1) {
                // Establish bidirectional connection
                lastConnectedCell.connections[lastConnectedFace] = { cell: loopNextRow, face: loopConnectFace };
                loopNextRow.connections[loopConnectFace] = { cell: lastConnectedCell, face: lastConnectedFace };
            }
            
            loopNextRows.push(loopNextRow);
            body.cells.push(loopNextRow);
            
            // Find output face for next loop-next-row
            const nextFaceForLoop = findOutputFace(loopNextRow);
            if (nextFaceForLoop !== -1) {
                lastConnectedCell = loopNextRow;
                lastConnectedFace = nextFaceForLoop;
            } else {
                console.error(`No output face found on loop-next-row ${i + 1}`);
                break;
            }
        }
    }
    
    // Add loop-next-layer between last loop-next-row and next cell
    if (loopNextRows.length > 0) {
        const lastLoop = loopNextRows[loopNextRows.length - 1];

        // lastConnectedFace already points to the output face of the last loop-next-row
        const loopNextLayer = checkTemplateCompatible(lastLoop, lastConnectedFace, loopNextLayerTemplate);
        
        if (loopNextLayer) {
            // Establish connection between loop-next-row and loop-next-layer
            const layerConnectFace = findCompatibleFace(loopNextLayerTemplate, lastLoop.template.faces[lastConnectedFace]);
            if (layerConnectFace !== -1) {
                lastLoop.connections[lastConnectedFace] = { cell: loopNextLayer, face: layerConnectFace };
                loopNextLayer.connections[layerConnectFace] = { cell: lastLoop, face: lastConnectedFace };
            }
            
            // Establish connection between loop-next-layer and nextCell
            const layerOutputFace = findOutputFace(loopNextLayer);
            if (layerOutputFace !== -1 && sv.canConnectFaces(loopNextLayer.template.faces[layerOutputFace], nextCell.template.faces[nextFace])) {
                nextCell.connections[nextFace] = { cell: loopNextLayer, face: layerOutputFace };
                loopNextLayer.connections[layerOutputFace] = { cell: nextCell, face: nextFace };
            }
            
            body.cells.push(loopNextLayer);
        } else {
            console.error("Failed to create loop-next-layer");
        }
    }
}

// Case 3: Same X coordinate - add yarn-next-row for direct connection
function addYarnNextRowForDirectConnection(currentCell, currentFace, nextCell, nextFace, direction) {
    const templateName = direction === "right" ? "yarn-next-row.right" : "yarn-next-row.left";
    const yarnNextRowTemplate = library.getTemplateByLongname(templateName);
    
    if (!yarnNextRowTemplate) {
        console.error(`${templateName} template not found`);
        return;
    }

    let yarnNextRow = checkTemplateCompatible(currentCell, currentFace, yarnNextRowTemplate);
    let connectFromCurrent = true;
    
    if (!yarnNextRow) {
        yarnNextRow = checkTemplateCompatible(nextCell, nextFace, yarnNextRowTemplate);
        connectFromCurrent = false;
    }
    
    if (!yarnNextRow) {
        console.error("Could not position yarn-next-row properly");
        return;
    }
    
    // Manually establish the connection
    if (connectFromCurrent) {
        // currentCell -> yarnNextRow -> nextCell
        const rowInputFace = findCompatibleFace(yarnNextRowTemplate, currentCell.template.faces[currentFace]);
        const rowOutputFace = findOutputFaceY1(yarnNextRow);
        
        if (rowInputFace !== -1) {
            currentCell.connections[currentFace] = { cell: yarnNextRow, face: rowInputFace };
            yarnNextRow.connections[rowInputFace] = { cell: currentCell, face: currentFace };
        }

        if (rowOutputFace !== -1 && sv.canConnectFaces(yarnNextRow.template.faces[rowOutputFace], nextCell.template.faces[nextFace])) {
            nextCell.connections[nextFace] = { cell: yarnNextRow, face: rowOutputFace };
            yarnNextRow.connections[rowOutputFace] = { cell: nextCell, face: nextFace };
        }
    } else {
        // nextCell -> yarnNextRow -> currentCell
        const rowInputFace = findCompatibleFace(yarnNextRowTemplate, nextCell.template.faces[nextFace]);
        const rowOutputFace = findOutputFaceY1(yarnNextRow);
        
        if (rowInputFace !== -1) {
            nextCell.connections[nextFace] = { cell: yarnNextRow, face: rowInputFace };
            yarnNextRow.connections[rowInputFace] = { cell: nextCell, face: nextFace };
        }
        
        if (rowOutputFace !== -1 && sv.canConnectFaces(yarnNextRow.template.faces[rowOutputFace], currentCell.template.faces[currentFace])) {
            currentCell.connections[currentFace] = { cell: yarnNextRow, face: rowOutputFace };
            yarnNextRow.connections[rowOutputFace] = { cell: currentCell, face: currentFace };
        }
    }
    
    body.cells.push(yarnNextRow);
}

// Case 1: +y1 face is protruding - add yarn-next-row, then yarn-next-column chain
function addYarnStructureForPlusY1Protruding(currentCell, currentFace, nextCell, nextFace, cellDistance, direction) {    
    const yarnNextRowTemplateName = direction === "right" ? "yarn-next-row.right" : "yarn-next-row.left";
    const yarnNextColumnTemplateName = direction === "right" ? "yarn-next-column.left" : "yarn-next-column.right";
    
    const yarnNextRowTemplate = library.getTemplateByLongname(yarnNextRowTemplateName);
    const yarnNextColumnTemplate = library.getTemplateByLongname(yarnNextColumnTemplateName);

    if (!yarnNextRowTemplate || !yarnNextColumnTemplate) {
    	if (!yarnNextRowTemplate) console.error("Required yarn templates not found:", yarnNextRowTemplateName);
        if (!yarnNextColumnTemplate) console.error("Required yarn templates not found:", yarnNextColumnTemplateName);
        return;
    }
    
    // First, add yarn-next-row connected to current cell's +y1 face
    const yarnNextRow = checkTemplateCompatible(currentCell, currentFace, yarnNextRowTemplate);
    if (!yarnNextRow) {
        console.error("Failed to create yarn-next-row");
        return;
    }
    
    // Connect currentCell +y1 <-> yarnNextRow -y1
    const rowInputFace = findCompatibleFace(yarnNextRowTemplate, currentCell.template.faces[currentFace]);
    if (rowInputFace !== -1) {
        currentCell.connections[currentFace] = { cell: yarnNextRow, face: rowInputFace };
        yarnNextRow.connections[rowInputFace] = { cell: currentCell, face: currentFace };
    }
    
    body.cells.push(yarnNextRow);
    
    // Create yarn-next-column chain
    const yarnNextColumns = [];
    let lastConnectedCell = yarnNextRow;
    let lastConnectedFace = findOutputFaceY1(yarnNextRow); // Find +y1 face of yarn-next-row
    
    for (let i = 0; i < cellDistance; i++) {
		// add yarn-next-column
        const yarnNextColumn = checkTemplateCompatible(lastConnectedCell, lastConnectedFace, yarnNextColumnTemplate);
        if (yarnNextColumn) {
            // Connect the chain
            const columnConnectFace = findCompatibleFace(yarnNextColumnTemplate, lastConnectedCell.template.faces[lastConnectedFace]);
            if (columnConnectFace !== -1) {
                lastConnectedCell.connections[lastConnectedFace] = { cell: yarnNextColumn, face: columnConnectFace };
                yarnNextColumn.connections[columnConnectFace] = { cell: lastConnectedCell, face: lastConnectedFace };
            }
            
            yarnNextColumns.push(yarnNextColumn);
            body.cells.push(yarnNextColumn);
            // Prepare for next iteration
            if (i < cellDistance - 1) {
                const nextFaceForColumn = findOutputFaceY1(yarnNextColumn);
                if (nextFaceForColumn !== -1) {
                    lastConnectedCell = yarnNextColumn;
                    lastConnectedFace = nextFaceForColumn;
                } else {
                    console.error(`No output face found on yarn-next-column ${i + 1}`);
                    break;
                }
            }
        } else {
            console.error(`Failed to create yarn-next-column ${i + 1}`);
            break;
        }
    }
    
    // Connect the last yarn-next-column to nextCell
    if (yarnNextColumns.length > 0) {
        const lastColumn = yarnNextColumns[yarnNextColumns.length - 1];
        const lastColumnOutputFace = findOutputFaceY1(lastColumn);
        
        if (lastColumnOutputFace !== -1 && sv.canConnectFaces(lastColumn.template.faces[lastColumnOutputFace], nextCell.template.faces[nextFace])) {
            nextCell.connections[nextFace] = { cell: lastColumn, face: lastColumnOutputFace };
            lastColumn.connections[lastColumnOutputFace] = { cell: nextCell, face: nextFace };
        }       
    }
}

// Case 2: -y1 face is protruding - add yarn-next-column chain, then connect to next cell  
function addYarnStructureForMinusY1Protruding(currentCell, currentFace, nextCell, nextFace, cellDistance, direction) {    
    const yarnNextRowTemplateName = direction === "right" ? "yarn-next-row.right" : "yarn-next-row.left";
    const yarnNextColumnTemplateName = direction === "right" ? "yarn-next-column.right" : "yarn-next-column.left";
    
    const yarnNextRowTemplate = library.getTemplateByLongname(yarnNextRowTemplateName);
    const yarnNextColumnTemplate = library.getTemplateByLongname(yarnNextColumnTemplateName);
    
    if (!yarnNextRowTemplate || !yarnNextColumnTemplate) {
        if (!yarnNextRowTemplate) console.error("Required yarn templates not found:", yarnNextRowTemplateName);
        if (!yarnNextColumnTemplate) console.error("Required yarn templates not found:", yarnNextColumnTemplateName);
        return;
    }
    
    // Start from nextCell -y1 face with yarn-next-row
    const yarnNextRow = checkTemplateCompatible(nextCell, nextFace, yarnNextRowTemplate);
    if (!yarnNextRow) {
        console.error("Failed to create yarn-next-row");
        return;
    }
    
    // Connect nextCell -y1 <-> yarnNextRow +y1
    const rowInputFace = findCompatibleFace(yarnNextRowTemplate, nextCell.template.faces[nextFace]);
    if (rowInputFace !== -1) {
        nextCell.connections[nextFace] = { cell: yarnNextRow, face: rowInputFace };
        yarnNextRow.connections[rowInputFace] = { cell: nextCell, face: nextFace };
    }
    
    body.cells.push(yarnNextRow);
    
    // Create yarn-next-column chain extending toward current cell
    const yarnNextColumns = [];
    let lastConnectedCell = yarnNextRow;
    let lastConnectedFace = findInputFaceY1(yarnNextRow); // Find -y1 face of yarn-next-row
    
    for (let i = 0; i < cellDistance; i++) {        
        const yarnNextColumn = checkTemplateCompatible(lastConnectedCell, lastConnectedFace, yarnNextColumnTemplate);
        
        if (yarnNextColumn) {
            // Connect the chain
            const columnConnectFace = findCompatibleFace(yarnNextColumnTemplate, lastConnectedCell.template.faces[lastConnectedFace]);
            if (columnConnectFace !== -1) {
                lastConnectedCell.connections[lastConnectedFace] = { cell: yarnNextColumn, face: columnConnectFace };
                yarnNextColumn.connections[columnConnectFace] = { cell: lastConnectedCell, face: lastConnectedFace };
            }
            
            yarnNextColumns.push(yarnNextColumn);
            body.cells.push(yarnNextColumn);
            
            // Prepare for next iteration
            if (i < cellDistance - 1) {
                const nextFaceForColumn = findInputFaceY1(yarnNextColumn);
                if (nextFaceForColumn !== -1) {
                    lastConnectedCell = yarnNextColumn;
                    lastConnectedFace = nextFaceForColumn;
                } else {
                    console.error(`No input face found on yarn-next-column ${i + 1}`);
                    break;
                }
            }
        } else {
            console.error(`Failed to create yarn-next-column ${i + 1}`);
            break;
        }
    }
    
    // Connect the last yarn-next-column to currentCell
    if (yarnNextColumns.length > 0) {
        const lastColumn = yarnNextColumns[yarnNextColumns.length - 1];
        const lastColumnInputFace = findInputFaceY1(lastColumn);
        
        if (lastColumnInputFace !== -1 && sv.canConnectFaces(lastColumn.template.faces[lastColumnInputFace], currentCell.template.faces[currentFace])) {
            currentCell.connections[currentFace] = { cell: lastColumn, face: lastColumnInputFace };
            lastColumn.connections[lastColumnInputFace] = { cell: currentCell, face: currentFace };
        }
    }
}

// Helper function to find output face with y1 type (+y1)
function findOutputFaceY1(cell) {
    for (let i = 0; i < cell.template.faces.length; i++) {
        if (cell.template.faces[i].type === "+y1") {
            return i;
        }
    }
    return -1;
}

// Helper function to find input face with y1 type (-y1)
function findInputFaceY1(cell) {
    for (let i = 0; i < cell.template.faces.length; i++) {
        if (cell.template.faces[i].type === "-y1") {
            return i;
        }
    }
    return -1;
}

// Helper function to check if a cell has another cell on specified face
function hasCellOnFace(cell, faceType) {
	for (let fi = 0; fi < cell.template.faces.length; fi++) {
		if (cell.template.faces[fi].type === faceType && 
			cell.connections[fi] !== null) {
			return true;
		}
	}
	return false;
}

// Helper function to check if a cell has another cell above it (connected via +L1 face)
function hasCellAbove(cell) {
    for (let fi = 0; fi < cell.template.faces.length; fi++) {
        if (cell.template.faces[fi].type === "+L1" && 
            cell.connections[fi] !== null) {
			// Check if the connected cell is a drop cell
            const connectedCell = cell.connections[fi].cell;
            if (connectedCell.template.name === "drop") {
                continue; // Ignore drop cells
            }
            return true;
        }
    }
    return false;
}

// Helper function to check if a cell has another cell below it (connected via -L1 face)
function hasCellBelow(cell) {
    for (let fi = 0; fi < cell.template.faces.length; fi++) {
        if (cell.template.faces[fi].type === "-L1" && 
            cell.connections[fi] !== null) {
            return true;
        }
    }
    return false;
}

// helper function to find a compatible face in the template for the target face
function findCompatibleFace(template, targetFace) {
    for (let i = 0; i < template.faces.length; i++) {
        if (sv.canConnectFaces(template.faces[i], targetFace)) {
            return i;
        }
    }
    return -1;
}

// helper function to find output face (starts with +)
function findOutputFace(cell) {
    for (let i = 0; i < cell.template.faces.length; i++) {
        if (cell.template.faces[i].type.startsWith('+')) {
            return i;
        }
    }
    return -1;
}

// helper function to find input face (starts with -)
function findInputFace(cell) {
    for (let i = 0; i < cell.template.faces.length; i++) {
        if (cell.template.faces[i].type.startsWith('-')) {
            return i;
        }
    }
    return -1;
}

// Helper function to fix bidirectional connections
function fixBidirectionalConnections(cell) {
    for (let fi = 0; fi < cell.connections.length; fi++) {
        const connection = cell.connections[fi];
        if (connection !== null) {
            const targetCell = connection.cell;
            const targetFace = connection.face;
            
            // Check if reverse connection exists
            if (targetCell.connections[targetFace] === null) {
                // Create reverse connection
                targetCell.connections[targetFace] = { cell: cell, face: fi };
            }
        }
    }
}

// Helper function to check if a cell has another cell to the right (connected via +l1 face)
function hasCellToRight(cell) {
    for (let fi = 0; fi < cell.template.faces.length; fi++) {
        if (cell.template.faces[fi].type === "+l1" && 
            cell.connections[fi] !== null) {
            return true;
        }
    }
    return false;
}

// Helper function to check if a cell has another cell to the left (connected via -l1 face)
function hasCellToLeft(cell) {
    for (let fi = 0; fi < cell.template.faces.length; fi++) {
        if (cell.template.faces[fi].type === "-l1" && 
            cell.connections[fi] !== null) {
            return true;
        }
    }
    return false;
}

// Helper function to get cell center coordinates
function getCellCenter(cell) {
    const center = gm.scale(1.0 / cell.vertices.length, 
        cell.vertices.reduce((acc, v) => gm.add(acc, v), gm.vec3(0,0,0)));
    return {
        x: Math.round(center[0] * 100) / 100, // round to avoid floating point errors
        y: Math.round(center[1] * 100) / 100,
        z: Math.round(center[2] * 100) / 100
    };
}

// Helper function to calculate distance between two cells in cell units
function calculateCellDistance(firstCell, secondCell, axis = 'X') {
    const firstCenter = getCellCenter(firstCell);
    const secondCenter = getCellCenter(secondCell);
    
    let distance;
    if (axis === 'X') {
        distance = Math.abs(firstCenter.x - secondCenter.x);
    } else if (axis === 'Y') {
        distance = Math.abs(firstCenter.y - secondCenter.y);
    } else if (axis === 'Z') {
        distance = Math.abs(firstCenter.z - secondCenter.z);
    } else {
        throw new Error(`Invalid axis: ${axis}. Use 'X', 'Y', or 'Z'.`);
    }
    
    const templateLength = getTemplateLength(firstCell.template, axis);
    const cellDistance = Math.round(distance / templateLength);
    
    return cellDistance;
}

// Helper function to add a cell at a specific position relative to a reference cell
function addCellAtPosition(referenceCell, templateLongname, xOffset, yOffset = 0, zOffset = 0) {
    const template = library.getTemplateByLongname(templateLongname);
    if (!template) {
        console.error(`Template "${templateLongname}" not found`);
        return null;
    }
    
    // Get reference cell center
    const refCenter = getCellCenter(referenceCell);
    
    // Calculate new position
    const templateLengthX = getTemplateLength(referenceCell.template, 'X');
	const templateLengthY = getTemplateLength(referenceCell.template, 'Y');
	const templateLengthZ = getTemplateLength(referenceCell.template, 'Z');
    const newPosition = gm.vec3(
        refCenter.x + (xOffset * templateLengthX),
        refCenter.y + (yOffset * templateLengthY),
        refCenter.z + (zOffset * templateLengthZ)
    );
    
    // Create transformation matrix
    const xform = gm.mat4x3(
        1, 0, 0,
        0, 1, 0,
        0, 0, 1,
        newPosition[0], newPosition[1], newPosition[2]
    );
    
    // Create and add new cell
    const newCell = sv.Cell.fromTemplate(template, xform);
    body.cells.push(newCell);
    
    return newCell;
}

// Helper function to explicitly connect two cells by specified face types
function connectFaces(cell1, cell1FaceType, cell2, cell2FaceType) {
    const face1Index = getFaceIndex(cell1, cell1FaceType);
    const face2Index = getFaceIndex(cell2, cell2FaceType);
    
    if (face1Index === -1 || face2Index === -1) {
        console.error(`Face types not found: ${cell1FaceType} or ${cell2FaceType}`);
        return false;
    }
    
    // Check if faces can be connected
    if (!sv.canConnectFaces(cell1.template.faces[face1Index], cell2.template.faces[face2Index])) {
        console.error(`Faces cannot be connected: ${cell1FaceType} and ${cell2FaceType}`);
        return false;
    }
    
    // Establish bidirectional connection
    cell1.connections[face1Index] = { cell: cell2, face: face2Index };
    cell2.connections[face2Index] = { cell: cell1, face: face1Index };
    return true;
}

/* ----- functions for decrease. start ----- */
function convertToDecreaseCells() {
    // Get the path information
    const path = window.path || determinePath();
    if (path.length === 0) return;
    
    // Group path items by layer and row
    const layers = {};
    path.forEach(item => {
		// only for knit templates
		if (!item.cell.template.longname.startsWith("knit.")) {
            return;
        }

        if (!layers[item.layerIndex]) layers[item.layerIndex] = {};
        if (!layers[item.layerIndex][item.rowIndex]) layers[item.layerIndex][item.rowIndex] = [];
        layers[item.layerIndex][item.rowIndex].push(item);
    });
    
    const layerIndices = Object.keys(layers).map(Number).sort((a, b) => a - b);

    // Process each layer
    layerIndices.forEach((layerIndex, layerArrayIndex) => {
        const layer = layers[layerIndex];
        const rowIndices = Object.keys(layer).map(Number).sort((a, b) => a - b);
        
        // Process each row (including the last one)
        for (let i = 0; i < rowIndices.length; i++) {
            const currentRowIndex = rowIndices[i];
            const currentRow = layer[currentRowIndex];
            
            let nextRow = null;
            let nextRowIndex = null;
            let isLastRowInLayer = (i === rowIndices.length - 1);
            
            if (!isLastRowInLayer) {
                // Not the last row in layer - use next row in same layer
                nextRowIndex = rowIndices[i + 1];
                nextRow = layer[nextRowIndex];
            } else {
                // Last row in layer - use first row of next layer
                const nextLayerIndex = layerArrayIndex + 1;
                if (nextLayerIndex < layerIndices.length) {
                    const nextLayerKey = layerIndices[nextLayerIndex];
                    const nextLayer = layers[nextLayerKey];
                    const nextLayerRowIndices = Object.keys(nextLayer).map(Number).sort((a, b) => a - b);
                    
                    if (nextLayerRowIndices.length > 0) {
                        nextRowIndex = nextLayerRowIndices[0]; // First row of next layer
                        nextRow = nextLayer[nextRowIndex];
                    }
                }
            }
            
            const currentRowDirection = currentRow[0].direction;
            
            // Only calculate distances if nextRow exists
            let cellDistanceAlongPath = 0;
            let cellDistanceAgainstPath = 0;
            
            if (nextRow) {
				// cellDistanceAlongPath is not in use. delete later
                cellDistanceAlongPath = calculateCellDistance(
                    currentRow[0].cell, 
                    nextRow[nextRow.length - 1].cell, 
                    'X'
                );

                cellDistanceAgainstPath = calculateCellDistance(
                    currentRow[currentRow.length - 1].cell, 
                    nextRow[0].cell, 
                    'X'
                );
                
                // Process against-path decrease
                if (cellDistanceAgainstPath > 0 && !hasCellOnFace(currentRow[currentRow.length - 1].cell, "+l1")) {
                    convertToDecreaseTurnAndChainAgainstPath(currentRow, currentRowDirection, cellDistanceAgainstPath);
                    convertToDecreaseEndAgainstPath(currentRow, currentRowDirection, cellDistanceAgainstPath);
                }

				// Process along-path decrease
				convertToDecreaseTurnAndChainAlongPath(currentRow, currentRowDirection, cellDistanceAgainstPath);
            }
        }
    });
}

function convertToDecreaseTurnAndChainAlongPath(currentRow, currentRowDirection, cellDistanceAgainstPath) {
    if (currentRow.length === 0) return;
    
    // Get template names
    const decreaseTurnTemplateName = currentRowDirection === "right" ? 
        "knit.decrease-turn-along-path.right.alt" : 
        "knit.decrease-turn-along-path.left.alt";
    const decreaseChainTemplateName = currentRowDirection === "right" ? 
        "knit.decrease-chain-along-path.right.alt" : 
        "knit.decrease-chain-along-path.left.alt";
    const decreaseEndAlongTemplateName = currentRowDirection === "right" ? 
        "knit.decrease-end-along-path.right.alt" : 
        "knit.decrease-end-along-path.left.alt";
    const decreaseEndBothTemplateName = currentRowDirection === "right" ? 
        "knit.decrease-end-both.right.alt" : 
        "knit.decrease-end-both.left.alt";
    
    const decreaseTurnTemplate = library.getTemplateByLongname(decreaseTurnTemplateName);
    const decreaseChainTemplate = library.getTemplateByLongname(decreaseChainTemplateName);
    const decreaseEndAlongTemplate = library.getTemplateByLongname(decreaseEndAlongTemplateName);
    const decreaseEndBothTemplate = library.getTemplateByLongname(decreaseEndBothTemplateName);   

	// To check if previous cell (row[i-1]) is decrease-turn template
    let previousCellIsDecreaseTurn = false;
	let previousCellIsDecreaseChain = false;

	// Currently, cellDistanceAgainsPath is calculated for increase too so it can't be used as is
	for (let i = 0; i < currentRow.length; i++) {
        const currentCell = currentRow[i].cell;
        
        // Check if +l1 face is unconnected
        const frontFaceIndex = getFaceIndex(currentCell, "+l1");
        if (frontFaceIndex === -1 || currentCell.connections[frontFaceIndex] !== null) {
            continue; // Skip if no +l1 face or already connected
        }
        
        if (i > 0) {
            const previousCell = currentRow[i - 1].cell;
            previousCellIsDecreaseTurn = previousCell.template.longname.includes("decrease-turn-along-path");
			previousCellIsDecreaseChain = previousCell.template.longname.includes("decrease-chain-along-path");
        }
        
        // Replace current cell
        if (previousCellIsDecreaseTurn || previousCellIsDecreaseChain && decreaseChainTemplate) {
            replaceCell(currentCell, decreaseChainTemplate);
        } else if (decreaseTurnTemplate) {
            replaceCell(currentCell, decreaseTurnTemplate);
        } 
        
        // Check next cell (row[i+1]) for end template
        if (i + 1 < currentRow.length) {
            const nextCell = currentRow[i + 1].cell;
            const nextCellFrontFaceIndex = getFaceIndex(nextCell, "+l1");
            
            if (nextCellFrontFaceIndex !== -1 && nextCell.connections[nextCellFrontFaceIndex] !== null) {
                // +l1 face is connected
                const isNextCellDecreaseEndAgainst = nextCell.template.longname === "knit.decrease-end-against-path.right.alt" ||
                                                   nextCell.template.longname === "knit.decrease-end-against-path.left.alt";
                if (isNextCellDecreaseEndAgainst && decreaseEndBothTemplate) {
                    replaceCell(nextCell, decreaseEndBothTemplate);
                } else if (decreaseEndAlongTemplate) {
                    replaceCell(nextCell, decreaseEndAlongTemplate);
                }
            }
        }
    }
}

function convertToDecreaseTurnAndChainAgainstPath(currentRow, currentRowDirection, cellDistanceAgainstPath/*, nextRowCellCount*/) {
    // Replace the first cell with decrease-turn-against-path
    const decreaseTurnTemplateName = currentRowDirection === "right" ? 
        "knit.decrease-turn-against-path.right.alt" : 
        "knit.decrease-turn-against-path.left.alt";
    
    const decreaseTurnTemplate = library.getTemplateByLongname(decreaseTurnTemplateName);
    if (decreaseTurnTemplate) {
		replaceCell(currentRow[currentRow.length - 1].cell, decreaseTurnTemplate);
    }
    
    // Add chain cells if distance > 1
    if (cellDistanceAgainstPath > 1) {
        const decreaseChainTemplateName = currentRowDirection === "right" ? 
            "knit.decrease-chain-against-path.right.alt" : 
            "knit.decrease-chain-against-path.left.alt";
        
        const decreaseChainTemplate = library.getTemplateByLongname(decreaseChainTemplateName);
        
        if (decreaseChainTemplate) {
            for (let i = 1; i < cellDistanceAgainstPath; i++) {
				const targetIndex = currentRow.length - 1 - i;
                if (targetIndex < currentRow.length) {
                    replaceCell(currentRow[targetIndex].cell, decreaseChainTemplate);
                }
            }
        }
    }
}

function convertToDecreaseEndAgainstPath(currentRow, currentRowDirection, cellDistanceAgainstPath) {
	const decreaseEndTemplateName = currentRowDirection === "right" ? 
		"knit.decrease-end-against-path.right.alt" : 
		"knit.decrease-end-against-path.left.alt";
	
	const decreaseEndTemplate = library.getTemplateByLongname(decreaseEndTemplateName);
	
	if (decreaseEndTemplate) {
		const targetIndex = currentRow.length - 1 - cellDistanceAgainstPath;
		if (targetIndex >= 0) {
			replaceCell(currentRow[targetIndex].cell, decreaseEndTemplate);
		}
	}
}


function processEndBothDecrease(currentRow, currentRowDirection, cellDistanceAlongPath) {
    const decreaseEndTemplateName = currentRowDirection === "right" ? 
        "knit.decrease-end-both.right.alt" : 
        "knit.decrease-end-both.left.alt";
    
    const decreaseEndTemplate = library.getTemplateByLongname(decreaseEndTemplateName);
    
    if (decreaseEndTemplate) {
        const targetIndex = cellDistanceAlongPath;
        if (targetIndex < currentRow.length) {
            replaceCell(currentRow[targetIndex].cell, decreaseEndTemplate);
        }
    }
}
/* ----- functions for decrease. end ----- */



/* ----- functions for increase. start ----- */
function convertToIncreaseCells() {    
	// Get the path information
    const path = window.path || determinePath();
    if (path.length === 0) return;
	
	path.forEach((pathItem, index) => {
        const cell = pathItem.cell;
        const direction = pathItem.direction;
        
        // Check if both -l1 and -L1 faces have no connections
        let hasBackConnection = false;
        let hasBottomConnection = false;
        
        for (let fi = 0; fi < cell.template.faces.length; fi++) {
            const faceType = cell.template.faces[fi].type;
            if (faceType === "-l1" && cell.connections[fi] !== null) {
                hasBackConnection = true;
            }
            if (faceType === "-L1" && cell.connections[fi] !== null) {
                hasBottomConnection = true;
            }
        }
        
		let newTemplateName = "";
		let newTemplate = null;

		// If back face has connection and bottom face has no connection, convert to increase
		// e.g., second layer
		if (!hasBackConnection && hasBottomConnection) {
			// handle increase then decrease right away
			if (cell.template.longname === "knit.decrease-turn-along-path.right.alt") {
				newTemplateName = "knit.increase-decrease-turn-along-path.right.alt";
			} else if (cell.template.longname === "knit.decrease-turn-along-path.left.alt") {
				newTemplateName =        "knit.increase-decrease-turn-along-path.left.alt";
			} else if (cell.template.longname === "knit.decrease-turn-against-path.right.alt") {
				newTemplateName =        "knit.increase-decrease-turn-against-path.right.alt";
			} else if (cell.template.longname === "knit.decrease-turn-against-path.left.alt") {
				newTemplateName =        "knit.increase-decrease-turn-against-path.left.alt";
			} else if (cell.template.longname === "knit.decrease-chain-along-path.right.alt") {
				newTemplateName =        "knit.increase-decrease-chain-along-path.right.alt";
			} else if (cell.template.longname === "knit.decrease-chain-along-path.left.alt") {
				newTemplateName =        "knit.increase-decrease-chain-along-path.left.alt";
			} else if (cell.template.longname === "knit.decrease-chain-against-path.right.alt") {
				newTemplateName =        "knit.increase-decrease-chain-against-path.right.alt";
			} else if (cell.template.longname === "knit.decrease-chain-against-path.left.alt") {
				newTemplateName =        "knit.increase-decrease-chain-against-path.left.alt";
			} else if (cell.template.longname === "knit.decrease-end-along-path.right.alt") {
				newTemplateName =        "knit.increase-decrease-end-along-path.right.alt";
			} else if (cell.template.longname === "knit.decrease-end-along-path.left.alt") {
				newTemplateName =        "knit.increase-decrease-end-along-path.left.alt";
			} else if (cell.template.longname === "knit.decrease-end-against-path.right.alt") {
				newTemplateName =        "knit.increase-decrease-end-against-path.right.alt";
			} else if (cell.template.longname === "knit.decrease-end-against-path.left.alt") {
				newTemplateName =        "knit.increase-decrease-end-against-path.left.alt";
			} else if (cell.template.longname === "knit.decrease-end-both.right.alt") {
				newTemplateName =        "knit.increase-decrease-end-both.right.alt";
			} else if (cell.template.longname === "knit.decrease-end-both.left.alt") {
				newTemplateName =        "knit.increase-decrease-end-both.left.alt";
			} else {
				newTemplateName = direction === "right" ? "knit.increase.right.alt" : "knit.increase.left.alt";
			}
		}
        // If both back and bottom faces have no connections, convert to increase-over-empty
		// e.g., first layer
        else if (!hasBackConnection && !hasBottomConnection) {
			// handle increase then decrease right away
			if (cell.template.longname === "knit.decrease-turn-along-path.right.alt") {
				newTemplateName = "knit.increase-decrease-turn-along-path-over-empty.right.alt";
			} else if (cell.template.longname === "knit.decrease-turn-along-path.left.alt") {
				newTemplateName =        "knit.increase-decrease-turn-along-path-over-empty.left.alt";
			} else if (cell.template.longname === "knit.decrease-turn-against-path.right.alt") {
				newTemplateName =        "knit.increase-decrease-turn-against-path-over-empty.right.alt";
			} else if (cell.template.longname === "knit.decrease-turn-against-path.left.alt") {
				newTemplateName =        "knit.increase-decrease-turn-against-path-over-empty.left.alt";
			} else if (cell.template.longname === "knit.decrease-chain-along-path.right.alt") {
				newTemplateName =        "knit.increase-decrease-chain-along-path-over-empty.right.alt";
			} else if (cell.template.longname === "knit.decrease-chain-along-path.left.alt") {
				newTemplateName =        "knit.increase-decrease-chain-along-path-over-empty.left.alt";
			} else if (cell.template.longname === "knit.decrease-chain-against-path.right.alt") {
				newTemplateName =        "knit.increase-decrease-chain-against-path-over-empty.right.alt";
			} else if (cell.template.longname === "knit.decrease-chain-against-path.left.alt") {
				newTemplateName =        "knit.increase-decrease-chain-against-path-over-empty.left.alt";
			} else if (cell.template.longname === "knit.decrease-end-along-path.right.alt") {
				newTemplateName =        "knit.increase-decrease-end-along-path-over-empty.right.alt";
			} else if (cell.template.longname === "knit.decrease-end-along-path.left.alt") {
				newTemplateName =        "knit.increase-decrease-end-along-path-over-empty.left.alt";
			} else if (cell.template.longname === "knit.decrease-end-against-path.right.alt") {
				newTemplateName =        "knit.increase-decrease-end-against-path-over-empty.right.alt";
			} else if (cell.template.longname === "knit.decrease-end-against-path.left.alt") {
				newTemplateName =        "knit.increase-decrease-end-against-path-over-empty.left.alt";
			} else if (cell.template.longname === "knit.decrease-end-both.right.alt") {
				newTemplateName =        "knit.increase-decrease-end-both-over-empty.right.alt";
			} else if (cell.template.longname === "knit.decrease-end-both.left.alt") {
				newTemplateName =        "knit.increase-decrease-end-both-over-empty.left.alt";
			} else {
				newTemplateName = direction === "right" ? "knit.increase-over-empty.right.alt" : "knit.increase-over-empty.left.alt";
			}
		}

		if(newTemplateName) {
            newTemplate = window.library.getTemplateByLongname(newTemplateName);
            if (newTemplate) {
                replaceCell(cell, newTemplate);
            } else {
                console.error(`Template "${newTemplateName}" not found in library`);
            }
		}
    });
}
/* ----- functions for increase. end ----- */


/* ----- functions for connect within rows. start ----- */
/**
 * connectWithinRows()
 * Connect cells within the same row using yarn-next-column blocks when there are gaps
 */
function connectWithinRows() {
    // Get the path information
    const path = window.path || determinePath();
    if (path.length === 0) return;
    
    // Group path items by layer and row
    const layers = {};
    path.forEach(item => {
        if (!layers[item.layerIndex]) layers[item.layerIndex] = {};
        if (!layers[item.layerIndex][item.rowIndex]) layers[item.layerIndex][item.rowIndex] = [];
        layers[item.layerIndex][item.rowIndex].push(item);
    });
    
    let connectionsCount = 0;
    
    // Process each layer
    Object.keys(layers).forEach(layerIndex => {
        const layer = layers[layerIndex];
        
        // Process each row within the layer
        Object.keys(layer).forEach(rowIndex => {
            const row = layer[rowIndex];
            
            // Sort row items by their position in the path to ensure correct order
            row.sort((a, b) => path.indexOf(a) - path.indexOf(b));
            
            // Process each cell in the row (except the last one)
            for (let i = 0; i < row.length - 1; i++) {
                const currentPathItem = row[i];
                const nextPathItem = row[i + 1];
                
                const currentCell = currentPathItem.cell;
                const nextCell = nextPathItem.cell;
                
                // Find +y1 face in current cell
                const currentY1Face = getFaceIndex(currentCell, "+y1");
                if (currentY1Face === -1) {
                    continue; // Skip if no +y1 face
                }
                
                // Check if +y1 face is unconnected
                if (currentCell.connections[currentY1Face] !== null) {
                    continue; // Skip if already connected
                }
                
                // Find -y1 face in next cell
                const nextY1Face = getFaceIndex(nextCell, "-y1");
                if (nextY1Face === -1) {
                    continue; // Skip if no -y1 face
                }
                
                // Calculate distance between current and next cell
                const cellDistance = calculateCellDistance(currentCell, nextCell, 'X');
                
                if (cellDistance <= 1) {
                    // Direct connection - no yarn-next-column needed
                    continue;
                }
                                
                // Determine direction and template name
                const direction = currentPathItem.direction;
                const yarnNextColumnTemplateName = direction === "right" ? 
                    "yarn-next-column.right" : "yarn-next-column.left";
                
                const yarnNextColumnTemplate = library.getTemplateByLongname(yarnNextColumnTemplateName);
                if (!yarnNextColumnTemplate) {
                    console.error(`Template "${yarnNextColumnTemplateName}" not found`);
                    continue;
                }
                
                // Create yarn-next-column chain
                const yarnNextColumns = [];
                let lastConnectedCell = currentCell;
                let lastConnectedFace = currentY1Face;
                
                for (let chainIndex = 0; chainIndex < cellDistance - 1; chainIndex++) {                    
                    const yarnNextColumn = checkTemplateCompatible(lastConnectedCell, lastConnectedFace, yarnNextColumnTemplate);
                    
                    if (yarnNextColumn) {
                        // Connect the chain
                        const columnConnectFace = findCompatibleFace(yarnNextColumnTemplate, lastConnectedCell.template.faces[lastConnectedFace]);
                        if (columnConnectFace !== -1) {
                            lastConnectedCell.connections[lastConnectedFace] = { cell: yarnNextColumn, face: columnConnectFace };
                            yarnNextColumn.connections[columnConnectFace] = { cell: lastConnectedCell, face: lastConnectedFace };
                        }
                        
                        yarnNextColumns.push(yarnNextColumn);
                        body.cells.push(yarnNextColumn);

                        // Prepare for next iteration (find +y1 face for next connection)
                        if (chainIndex < cellDistance - 2) {
                            const nextFaceForColumn = getFaceIndex(yarnNextColumn, "+y1");
                            if (nextFaceForColumn !== -1) {
                                lastConnectedCell = yarnNextColumn;
                                lastConnectedFace = nextFaceForColumn;
                            } else {
                                console.error(`No +y1 face found on yarn-next-column ${chainIndex + 1}`);
                                break;
                            }
                        }
                        
                        connectionsCount++;
                    } else {
                        console.error(`Failed to create yarn-next-column ${chainIndex + 1}`);
                        break;
                    }
                }
                
                // Connect the last yarn-next-column to nextCell
                if (yarnNextColumns.length > 0) {
                    const lastColumn = yarnNextColumns[yarnNextColumns.length - 1];
                    const lastColumnOutputFace = getFaceIndex(lastColumn, "+y1");
                    
                    if (lastColumnOutputFace !== -1 && sv.canConnectFaces(lastColumn.template.faces[lastColumnOutputFace], nextCell.template.faces[nextY1Face])) {
                        nextCell.connections[nextY1Face] = { cell: lastColumn, face: lastColumnOutputFace };
                        lastColumn.connections[lastColumnOutputFace] = { cell: nextCell, face: nextY1Face };
                    }
                }
            }
        });
    });
    
    if (connectionsCount > 0) {
        bodyDirty();
        requestRedraw();
    }
}

/* ----- functions for connect within rows. end ----- */


/* ----- function to connect within columns using loop-next-row. start ----- */
/**
 * connectWithinColumns()
 * Connect +l1 and -l1 faces within the same column using loop-next-row blocks
 */
function connectWithinColumns() {
   const path = window.path || determinePath();
   if (path.length === 0) return;
   
   // Group path items by layer and column
   const layers = {};
   path.forEach(item => {
       if (!layers[item.layerIndex]) layers[item.layerIndex] = {};
       if (!layers[item.layerIndex][item.columnIndex]) layers[item.layerIndex][item.columnIndex] = [];
       layers[item.layerIndex][item.columnIndex].push(item);
   });
   
   let connectionsCount = 0;
   
   // Process each layer
   Object.keys(layers).forEach(layerIndex => {
       const layer = layers[layerIndex];
       
       // Process each column within the layer
       Object.keys(layer).forEach(columnIndex => {
           const column = layer[columnIndex];
           
           // Find cells with unconnected +l1 faces (cellStart)
           const cellsWithFrontUnconnected = column.filter(item => {
               const frontFaceIndex = getFaceIndex(item.cell, "+l1");
               return frontFaceIndex !== -1 && item.cell.connections[frontFaceIndex] === null;
           });
           
           // Find cells with unconnected -l1 faces (cellEnd)
           const cellsWithBackUnconnected = column.filter(item => {
               const backFaceIndex = getFaceIndex(item.cell, "-l1");
               return backFaceIndex !== -1 && item.cell.connections[backFaceIndex] === null;
           });
           
           // Process each +l1 face
           cellsWithFrontUnconnected.forEach(itemStart => {
               const cellStart = itemStart.cell;
               const faceStart = getFaceIndex(cellStart, "+l1");
               
               // Find the closest -l1 face in later rows within the same column
               let closestItemEnd = null;
               let cellDistance = Infinity;

               cellsWithBackUnconnected.forEach(candidate => {
                   // Only consider cells in later rows (higher rowIndex)
                   if (candidate.rowIndex > itemStart.rowIndex) {
                       const yDistance = calculateCellDistance(itemStart.cell, candidate.cell, 'Y');
                       if (yDistance < cellDistance) {
                           const backFaceIndex = getFaceIndex(candidate.cell, "-l1");
                           if (backFaceIndex !== -1 && candidate.cell.connections[backFaceIndex] === null) {
                               cellDistance = yDistance;
                               closestItemEnd = candidate;
                           }
                       }
                   }
               });

               if (!closestItemEnd) {
                   return;
               }

               const cellEnd = closestItemEnd.cell;
               const faceEnd = getFaceIndex(cellEnd, "-l1");
                              
               if (cellDistance > 0) {
                   // Connect with loop-next-row chain
                   addLoopNextRow(cellStart, faceStart, cellEnd, faceEnd, cellDistance);
                   connectionsCount++;
               }
           });
       });
   });
      
   if (connectionsCount > 0) {
       bodyDirty();
       requestRedraw();
   }
   
   return;
}

/**
 * addLoopNextRow()
 * Add a chain of loop-next-row blocks between two cells
 */
function addLoopNextRow(cellStart, faceStart, cellEnd, faceEnd, cellDistance) {    
    const loopNextRowTemplate = library.getTemplateByLongname("loop-next-row");
    
    if (!loopNextRowTemplate) {
        console.error("loop-next-row template not found");
        return;
    }
        
    // Create loop-next-row chain
    const loopNextRows = [];
    let lastConnectedCell = cellStart;
    let lastConnectedFace = faceStart;
    
    for (let i = 0; i < cellDistance; i++) {
        
        const loopNextRow = checkTemplateCompatible(lastConnectedCell, lastConnectedFace, loopNextRowTemplate);
        
        if (loopNextRow) {
            // Establish connection
            const loopConnectFace = findCompatibleFace(loopNextRowTemplate, lastConnectedCell.template.faces[lastConnectedFace]);
            if (loopConnectFace !== -1) {
                lastConnectedCell.connections[lastConnectedFace] = { cell: loopNextRow, face: loopConnectFace };
                loopNextRow.connections[loopConnectFace] = { cell: lastConnectedCell, face: lastConnectedFace };
            }
            
            loopNextRows.push(loopNextRow);
            body.cells.push(loopNextRow);
            
            // Prepare for next connection or final connection to cellEnd
            if (i < cellDistance - 1) {
                // Find the output face for next loop-next-row
                const nextFaceForLoop = findOutputFace(loopNextRow);
                if (nextFaceForLoop !== -1) {
                    lastConnectedCell = loopNextRow;
                    lastConnectedFace = nextFaceForLoop;
                } else {
                    console.error(`No output face found on loop-next-row ${i + 1}`);
                    break;
                }
            } else {
                // Last loop-next-row - connect to cellEnd
                const finalOutputFace = findOutputFace(loopNextRow);
                if (finalOutputFace !== -1 && sv.canConnectFaces(loopNextRow.template.faces[finalOutputFace], cellEnd.template.faces[faceEnd])) {
                    cellEnd.connections[faceEnd] = { cell: loopNextRow, face: finalOutputFace };
                    loopNextRow.connections[finalOutputFace] = { cell: cellEnd, face: faceEnd };
                } else {
                    console.error("Failed to connect final loop-next-row to cellEnd");
                }
            }
        }
    }
    
}
/* ----- function to connect within columns using loop-next-row. end ----- */


/* ----- functions for indicate loop. start ----- */
/**
 * colorYarn - Change yarn colors for yarns connected to specific face types
 * @param {Object} targetItem - The path item containing the cell
 * @param {Array} color - The RGB color array to apply (e.g., [0.0, 1.0, 0.0])
 * @param {string} startFaceType - The face type where yarn begins (e.g., "-d2")
 * @param {string} endFaceType - Optional. The face type where yarn ends (e.g., "+d2")
 */
function colorYarn(targetItem, color, startFaceType, endFaceType = null) {
    if (!targetItem || !targetItem.cell) return;
    
    const cell = targetItem.cell;
    const template = cell.template;
    
    // Initialize cell-specific yarn colors if not exists
    if (!cell.yarnColors) {
        cell.yarnColors = [];
        for (let i = 0; i < template.yarns.length; i++) {
            cell.yarnColors[i] = visTubes.col_rgb; // default color
        }
    }
    
    // Find face indices for the specified face types
    let startFaceIndex = -1;
    let endFaceIndex = -1;
    
    for (let fi = 0; fi < template.faces.length; fi++) {
        if (template.faces[fi].type === startFaceType) {
            startFaceIndex = fi;
        }
        if (endFaceType && template.faces[fi].type === endFaceType) {
            endFaceIndex = fi;
        }
    }
    
    if (startFaceIndex === -1) return;
    
    // Color yarns based on the parameters
    for (let yarnIndex = 0; yarnIndex < template.yarns.length; yarnIndex++) {
        const yarn = template.yarns[yarnIndex];
        let shouldColor = false;
        
        if (endFaceType === null) {
            // Original behavior: color yarns that begin or end at startFaceType
            if (yarn.begin === startFaceIndex || yarn.end === startFaceIndex) {
                shouldColor = true;
            }
        } else {
            // New behavior: color yarns that go from startFaceType to endFaceType (or vice versa)
            if (endFaceIndex !== -1) {
                if ((yarn.begin === startFaceIndex && yarn.end === endFaceIndex) ||
                    (yarn.begin === endFaceIndex && yarn.end === startFaceIndex)) {
                    shouldColor = true;
                }
            }
        }
        
        // Apply color if this yarn matches the criteria
        if (shouldColor) {
            cell.yarnColors[yarnIndex] = color;
        }
    }
}

/**
 * indicateLoop - Highlight the loop connection between selectedItem and its connected item
 * @param {Object} selectedItem - The currently selected path item
 * @param {Array} color - The RGB color array to use for highlighting (default: green)
 */
function indicateLoop(selectedItem, color = [0.0, 1.0, 0.0]) {
    // Reset all yarn colors to default first
    resetAllYarnColors();
    
    if (!selectedItem || !selectedItem.cell) return;
	if (selectedItem.cell.template.longname.includes("bind-off")) return; // Skip bind-off cells
    
    const cell = selectedItem.cell;
    
    // Find the +l1 face and its connection
    let frontFaceIndex = getFaceIndex(cell, "+l1");
    const connectionFront = cell.connections[frontFaceIndex];
    let connectedItemFront = null;

    if (connectionFront && connectionFront.cell) {
        // Create a mock path item for the connected cell
        connectedItemFront = {
            cell: connectionFront.cell,
            cellID: body.cells.indexOf(connectionFront.cell)
        };
    }

    // Check if the connected cell is loop-to-layer
    if (connectedItemFront && connectedItemFront.cell.template.longname.includes("loop-to-layer")) {
        // Color loop-to-layer's -l1 face yarns
        colorYarn(connectedItemFront, color, "-l1");
        
        // Find loop-to-layer's +L1 face connection
        const loopToLayerTopFaceIndex = getFaceIndex(connectedItemFront.cell, "+L1");
        if (loopToLayerTopFaceIndex !== -1 && connectedItemFront.cell.connections[loopToLayerTopFaceIndex]) {
            const topConnection = connectedItemFront.cell.connections[loopToLayerTopFaceIndex];
            const topConnectedItem = {
                cell: topConnection.cell,
                cellID: body.cells.indexOf(topConnection.cell)
            };
            
            // Color the top connected cell's -L1 face yarns
            colorYarn(topConnectedItem, color, "-L1");
        }
    }

    // Follow +l1/-l1 connections until reaches a knit template
    let currentConnectedItem = connectedItemFront;
    let loopHeadItem = null;

    while (currentConnectedItem && currentConnectedItem.cell) {
        const currentCell = currentConnectedItem.cell;
        const isKnitTemplate = currentCell.template.longname.includes("knit.");
        
        if (isKnitTemplate) {
            // Found a knit template - look for loop head
            let topFaceIndexOfCurrent = getFaceIndex(currentCell, "+L1");
            const connectionTopOfCurrent = currentCell.connections[topFaceIndexOfCurrent];

            if (connectionTopOfCurrent && connectionTopOfCurrent.cell) {
                loopHeadItem = {
                    cell: connectionTopOfCurrent.cell,
                    cellID: body.cells.indexOf(connectionTopOfCurrent.cell)
                };
            }
            break; // Stop when we find a knit template
        } else {
			// Not a knit / loop-to-layer template
			// Color the current non-knit cell's -l1 face yarn
            colorYarn(currentConnectedItem, color, "-l1");

            // If there is a next cell continue following +l1 connections (e.g. loop-next-row)
            let nextFrontFaceIndex = getFaceIndex(currentCell, "+l1");
            const nextConnection = currentCell.connections[nextFrontFaceIndex];
            
            if (nextConnection && nextConnection.cell) {
                
                // Move to the next cell
                currentConnectedItem = {
                    cell: nextConnection.cell,
                    cellID: body.cells.indexOf(nextConnection.cell)
                };
            } else {
                // No more connections - stop
                break;
            }
        }
    }

	// Follow +y1/-y1 connections until reaches a knit template
    let rightFaceIndex = getFaceIndex(cell, "+y1");
    const connectionRight = cell.connections[rightFaceIndex];
    let connectedItemRight = null;

    if (connectionRight && connectionRight.cell) {
        connectedItemRight = {
            cell: connectionRight.cell,
            cellID: body.cells.indexOf(connectionRight.cell)
        };
    }

    let currentConnectedItemY1 = connectedItemRight;

    while (currentConnectedItemY1 && currentConnectedItemY1.cell) {
        const currentCell = currentConnectedItemY1.cell;
        const isKnitTemplate = currentCell.template.longname.includes("knit.");
        
        if (isKnitTemplate) {
            // Found a knit template - stop tracing +y1 connections
            break;
        } else {
            // Not a knit template - color its -y1 face yarn and continue following +y1 connections
            colorYarn(currentConnectedItemY1, color, "-y1");
            
            let nextRightFaceIndex = getFaceIndex(currentCell, "+y1");
            const nextConnection = currentCell.connections[nextRightFaceIndex];
            
            if (nextConnection && nextConnection.cell) {
                // Move to the next cell
                currentConnectedItemY1 = {
                    cell: nextConnection.cell,
                    cellID: body.cells.indexOf(nextConnection.cell)
                };
            } else {
                // No more connections - stop
                break;
            }
        }
    }

    // Special handling for increase cells
    if (cell.template.longname.includes("increase")) {
        colorYarn(selectedItem, color, "-y1");

        // Find the +L1 face and its connection
        let topFaceIndex = getFaceIndex(cell, "+L1");

        // Only for increase cells, color yarn of top connection too
        const connectionTop = cell.connections[topFaceIndex];
        let connectedItemTop = null;

        if (connectionTop && connectionTop.cell) {
            // Create a mock path item for the connected cell
            connectedItemTop = {
                cell: connectionTop.cell,
                cellID: body.cells.indexOf(connectionTop.cell)
            };
        }

        colorYarn(connectedItemTop, color, "-L1");
    }

	// Special handling for decrease cells
	if (cell.template.longname.includes("decrease")) {
		// colorYarn(selectedItem, "-d1", color);
		colorYarn(selectedItem, color, "+d1");
		colorYarn(selectedItem, color, "-d2");
		// colorYarn(selectedItem, "+d2", color);
		
		// Handle +d1 face connection
		const plusD1FaceIndex = getFaceIndex(cell, "+d1");
		if (plusD1FaceIndex !== -1 && cell.connections[plusD1FaceIndex]) {
			const plusD1Connection = cell.connections[plusD1FaceIndex];
			const connectedCellPlusD1 = {
				cell: plusD1Connection.cell,
				cellID: body.cells.indexOf(plusD1Connection.cell)
			};
			// Color the connected cell's yarn starting and ending on -d1 face
			colorYarn(connectedCellPlusD1, color, "-d1", "-d1");
		}
		
		// Handle -d2 face connection
		const minusD2FaceIndex = getFaceIndex(cell, "-d2");
		if (minusD2FaceIndex !== -1 && cell.connections[minusD2FaceIndex]) {
			const minusD2Connection = cell.connections[minusD2FaceIndex];
			const connectedCellMinusD2 = {
				cell: minusD2Connection.cell,
				cellID: body.cells.indexOf(minusD2Connection.cell)
			};
			// Color the connected cell's yarn starting and ending on +d2 face
			colorYarn(connectedCellMinusD2, color, "+d2", "+d2");
		}
	}
    
    // Color the selected item's +l1 face yarns
    colorYarn(selectedItem, color, "+l1");
    
    // Color the final connected knit item's -l1 face yarns if it exists
    if (currentConnectedItem && currentConnectedItem.cell && 
        currentConnectedItem.cell.template.longname.includes("knit.")) {
        colorYarn(currentConnectedItem, color, "-l1");
    }

    // Color the loop head yarn (only if we found a knit template and its loop head)
    if (loopHeadItem) {
        colorYarn(loopHeadItem, color, "-L1");
    }
}

/**
 * resetAllYarnColors - Reset all yarn colors to their original colors
 */
function resetAllYarnColors() {
    for (let cell of body.cells) {
        // Reset cell-specific yarn colors
        if (cell.yarnColors) {
            for (let i = 0; i < cell.yarnColors.length; i++) {
                cell.yarnColors[i] = visTubes.col_rgb;
            }
        }
    }
}

/**
 * updateLoopIndication - Update the loop indication based on current selectedLoopIndex
 */
function updateLoopIndication() {
    if (!indicateLoopMode) return;
    
    const path = window.path;
    if (!path || path.length === 0) {
        return;
    }
    
    // Clamp selectedLoopIndex to valid range
    selectedLoopIndex = Math.max(0, Math.min(selectedLoopIndex, body.cells.length - 1));
    
    const selectedItem = path[selectedLoopIndex];
    indicateLoop(selectedItem);
    
    // Update UI and redraw
    bodyDirty();
    requestRedraw();
}
/* ----- functions for indicate loop. end ----- */

/* ----- function to handle the "add another row in first layer" rule. start----- */
// function to add unlabeled.right.alt cells between layers
function addUnlabeledCellsBetweenLayers() {
    // Get the path information
    const path = window.path || determinePath();
    if (path.length === 0) return;
    
    // Get unique layer indices
    const layerIndices = [...new Set(path.map(item => item.layerIndex))].sort((a, b) => a - b);
    
    let totalAddedCells = 0;
    
    // Process all layer transitions (not just first to second)
    for (let i = 0; i < layerIndices.length - 1; i++) {
        const currentLayerIndex = layerIndices[i];
        const nextLayerIndex = layerIndices[i + 1];

        // get current path in case it was modified
        const currentPath = determinePath();
        
        // Get last row of current layer
        const currentLayerItems = currentPath.filter(item => item.layerIndex === currentLayerIndex);
        const lastRowIndexCurrentLayer = Math.max(...currentLayerItems.map(item => item.rowIndex));
        const lastRowCurrentLayer = currentLayerItems.filter(item => item.rowIndex === lastRowIndexCurrentLayer);
        
        // Get first row of next layer
        const nextLayerItems = currentPath.filter(item => item.layerIndex === nextLayerIndex);
        const firstRowIndexNextLayer = Math.min(...nextLayerItems.map(item => item.rowIndex));
        const firstRowNextLayer = nextLayerItems.filter(item => item.rowIndex === firstRowIndexNextLayer);
        
        // Calculate Y distance between the rows
        const yDistance = calculateCellDistance(lastRowCurrentLayer[0].cell, firstRowNextLayer[0].cell, 'Y');
        
        // Check if last row of current layer has no bottom connection
        let lastRowHasNoBottomConnection = true;
        for (let pathItem of lastRowCurrentLayer) {
            const cell = pathItem.cell;
            // Check if any cell in last row has bottom connection (-L1 face)
            const bottomFaceIndex = getFaceIndex(cell, "-L1");
            if (bottomFaceIndex !== -1 && cell.connections[bottomFaceIndex] !== null) {
                lastRowHasNoBottomConnection = false;
                break;
            }
        }
        
        // Check if Y coordinates are the same AND last row has no bottom connection
        if (yDistance === 0 && lastRowHasNoBottomConnection) {
            // Get unlabeled.right.alt template
            const unlabeledRightAltTemplate = library.getTemplateByLongname("unlabeled.right.alt");
            if (!unlabeledRightAltTemplate) {
                console.error("unlabeled.right.alt template not found");
                continue;
            }
            
            let addedCells = 0;

            // Add unlabeled.right.alt to each cell in the last row of current layer
            lastRowCurrentLayer.forEach(pathItem => {
                const cell = pathItem.cell;
                
                // Find front face (+l1)
                const frontFaceIndex = getFaceIndex(cell, "+l1");
                if (frontFaceIndex === -1) {
                    return;
                }
                
                // Check if front face is already connected
                if (cell.connections[frontFaceIndex] !== null) {
                    return;
                }

                // Position unlabeled.right.alt
                const unlabeledCell = checkTemplateCompatible(cell, frontFaceIndex, unlabeledRightAltTemplate);
                if (unlabeledCell) {
                    // Manually establish connection
                    const unlabeledCellBackFace = getFaceIndex(unlabeledRightAltTemplate, "-l1");
                    if (unlabeledCellBackFace !== -1) {
                        cell.connections[frontFaceIndex] = { cell: unlabeledCell, face: unlabeledCellBackFace };
                        unlabeledCell.connections[unlabeledCellBackFace] = { cell: cell, face: frontFaceIndex };

                        body.cells.push(unlabeledCell);
                        addedCells++;
                        
                    } else {
                        console.error("Could not find -l1 face in unlabeled.right.alt template");
                    }
                } else {
                    console.error(`Could not position unlabeled.right.alt on cell ${pathItem.cellID}`);
                }
            });
            
            // process after forEach loop
            if (addedCells > 0) {
                totalAddedCells += addedCells;
            }
        }
    }
    
    // update once after processing all layers
    if (totalAddedCells > 0) {
        determinePath();
        bodyDirty();
        requestRedraw();
    }
}
/* ----- function to handle the "add one row in first layer" rule. end----- */

/* ----- functions to control yarn-based layer visibility. start----- */
// Global cache for layer visibility yarn
let layerVisibilityYarnCache = null;
let lastLayerVisibilityYarnPath = null;

/**
 * checkLayerVisibilityYarn - Check if a specific yarn in a cell should be visible
 * @param {Object} cell - The cell containing the yarn
 * @param {number} yarnIndex - The index of the yarn within the cell
 * @returns {boolean} - True if yarn should be visible
 */
function checkLayerVisibilityYarn(cell, yarnIndex) {
    const layerVisibilityYarnBoxes = document.getElementById("layer-visibility-yarn-form");
    if (!layerVisibilityYarnBoxes) return true;
    
    // Show selected template regardless of layer visibility
    if (window.template && cell.template === window.template) {
        return true;
    }
    
    const path = window.path || determinePath();
    if (path.length === 0) return true;
    
    // Create a lightweight hash of the path for change detection
    const currentPathHash = JSON.stringify(path.map(item => ({
        cellID: item.cellID,
        layerIndex: item.layerIndex
    })));
    
    // Update cache if path has changed
    if (layerVisibilityYarnCache === null || 
        lastLayerVisibilityYarnPath !== currentPathHash) {
        updateLayerVisibilityYarnCache(path, layerVisibilityYarnBoxes);
        lastLayerVisibilityYarnPath = currentPathHash;
    }
    
    const yarnKey = `${body.cells.indexOf(cell)}-${yarnIndex}`;
    return layerVisibilityYarnCache.has(yarnKey);
}

/**
 * updateLayerVisibilityYarnCache - Update the cache of visible yarns based on layer visibility yarn checkboxes
 */
function updateLayerVisibilityYarnCache(path, layerVisibilityYarnBoxes) {
    layerVisibilityYarnCache = new Set();
    
    // For each checked layer visibility yarn
    for (let layerCheckboxIndex = 0; layerCheckboxIndex < layerVisibilityYarnBoxes.children.length; layerCheckboxIndex++) {
        const checkbox = layerVisibilityYarnBoxes.children[layerCheckboxIndex];
        if (!checkbox.checked) continue;
        
        // Find all cells with this layerIndex
        const layerCells = path.filter(pathItem => pathItem.layerIndex === layerCheckboxIndex);
        
        // For each cell in this layer, trace yarns using indicateLoop algorithm
        for (let pathItem of layerCells) {
            const visibleYarns = traceYarnsForLayerVisibility(pathItem);
            
            // Add all traced yarns to visibility cache
            for (let yarnInfo of visibleYarns) {
                const yarnKey = `${body.cells.indexOf(yarnInfo.cell)}-${yarnInfo.yarnIndex}`;
                layerVisibilityYarnCache.add(yarnKey);
            }
        }
    }
}

/**
 * traceYarnsForLayerVisibility - Trace all yarns connected to a cell using indicateLoop algorithm
 * @param {Object} pathItem - The path item containing the cell
 * @returns {Array} - Array of {cell, yarnIndex} objects representing visible yarns
 */
function traceYarnsForLayerVisibility(pathItem) {
    const cell = pathItem.cell;
    const visibleYarns = [];
    
    // Helper function to add yarns from a cell and face type to the visible list
    function addYarnsFromFaceForLayerVisibility(targetCell, faceType, startFaceType = null, endFaceType = null) {
        if (!targetCell) return;
        
        const template = targetCell.template;
        
        // Find face having faceType (e.g. "-l1") and aquire its index
        let faceIndex = -1;
        for (let fi = 0; fi < template.faces.length; fi++) {
            if (template.faces[fi].type === faceType) {
                faceIndex = fi;
                break;
            }
        }
        
        if (faceIndex === -1) return;
        
        // Find yarns connected to this face
        for (let yarnIndex = 0; yarnIndex < template.yarns.length; yarnIndex++) {
            const yarn = template.yarns[yarnIndex];
            let shouldAdd = false;
            
            if (startFaceType === null && endFaceType === null) {
                // Original behavior: yarn begins or ends at this face
                if (yarn.begin === faceIndex || yarn.end === faceIndex) {
                    shouldAdd = true;
                }
            } else if (startFaceType !== null && endFaceType !== null) {
                // Specific path behavior: yarn goes from startFaceType to endFaceType
                let startFaceIndex = -1;
                let endFaceIndex = -1;
                
                for (let fi = 0; fi < template.faces.length; fi++) {
                    if (template.faces[fi].type === startFaceType) startFaceIndex = fi;
                    if (template.faces[fi].type === endFaceType) endFaceIndex = fi;
                }
                
                if (startFaceIndex !== -1 && endFaceIndex !== -1) {
                    if ((yarn.begin === startFaceIndex && yarn.end === endFaceIndex) ||
                        (yarn.begin === endFaceIndex && yarn.end === startFaceIndex)) {
                        shouldAdd = true;
                    }
                }
            }
            
            if (shouldAdd) {
                visibleYarns.push({ cell: targetCell, yarnIndex: yarnIndex });
            }
        }
    }
    
    // Follow +l1/-l1 connections until we reach a knit template (same as indicateLoop)
    let frontFaceIndex = getFaceIndex(cell, "+l1");
    const connectionFront = cell.connections[frontFaceIndex];
    let connectedItemFront = null;

    if (connectionFront && connectionFront.cell) {
        connectedItemFront = {
            cell: connectionFront.cell,
            cellID: body.cells.indexOf(connectionFront.cell)
        };
    }

    // Check if the connected cell is loop-to-layer
    if (connectedItemFront && connectedItemFront.cell.template.longname.includes("loop-to-layer")) {
        // Add loop-to-layer's -l1 face yarns
        addYarnsFromFaceForLayerVisibility(connectedItemFront.cell, "-l1");
        
        // Find loop-to-layer's +L1 face connection
        const loopToLayerTopFaceIndex = getFaceIndex(connectedItemFront.cell, "+L1");
        if (loopToLayerTopFaceIndex !== -1 && connectedItemFront.cell.connections[loopToLayerTopFaceIndex]) {
            const topConnection = connectedItemFront.cell.connections[loopToLayerTopFaceIndex];
            
            // Add the top connected cell's -L1 face yarns
            addYarnsFromFaceForLayerVisibility(topConnection.cell, "-L1");
        }
    }

    let currentConnectedItem = connectedItemFront;
    let loopHeadItem = null;

    while (currentConnectedItem && currentConnectedItem.cell) {
        const currentCell = currentConnectedItem.cell;
        const isKnitTemplate = currentCell.template.longname.includes("knit.");
        
        if (isKnitTemplate) {
            // Found a knit template - look for loop head
            let topFaceIndexOfCurrent = getFaceIndex(currentCell, "+L1");
            const connectionTopOfCurrent = currentCell.connections[topFaceIndexOfCurrent];

            if (connectionTopOfCurrent && connectionTopOfCurrent.cell) {
                loopHeadItem = {
                    cell: connectionTopOfCurrent.cell,
                    cellID: body.cells.indexOf(connectionTopOfCurrent.cell)
                };
            }
            break;
        } else {
            // Not a knit template - add yarns from -l1 face
            addYarnsFromFaceForLayerVisibility(currentConnectedItem.cell, "-l1");
            
            let nextFrontFaceIndex = getFaceIndex(currentCell, "+l1");
            const nextConnection = currentCell.connections[nextFrontFaceIndex];
            
            if (nextConnection && nextConnection.cell) {
                currentConnectedItem = {
                    cell: nextConnection.cell,
                    cellID: body.cells.indexOf(nextConnection.cell)
                };
            } else {
                break;
            }
        }
    }

    // Follow +y1/-y1 connections (same as indicateLoop)
    let rightFaceIndex = getFaceIndex(cell, "+y1");
    const connectionRight = cell.connections[rightFaceIndex];
    let connectedItemRight = null;

    if (connectionRight && connectionRight.cell) {
        connectedItemRight = {
            cell: connectionRight.cell,
            cellID: body.cells.indexOf(connectionRight.cell)
        };
    }

    let currentConnectedItemY1 = connectedItemRight;

    while (currentConnectedItemY1 && currentConnectedItemY1.cell) {
        const currentCell = currentConnectedItemY1.cell;
        const isKnitTemplate = currentCell.template.longname.includes("knit.");
        
        if (isKnitTemplate) {
            break;
        } else {
            addYarnsFromFaceForLayerVisibility(currentConnectedItemY1.cell, "-y1");
            
            let nextRightFaceIndex = getFaceIndex(currentCell, "+y1");
            const nextConnection = currentCell.connections[nextRightFaceIndex];
            
            if (nextConnection && nextConnection.cell) {
                currentConnectedItemY1 = {
                    cell: nextConnection.cell,
                    cellID: body.cells.indexOf(nextConnection.cell)
                };
            } else {
                break;
            }
        }
    }

    // Add yarns from the selected cell
    addYarnsFromFaceForLayerVisibility(cell, "+l1");
    addYarnsFromFaceForLayerVisibility(cell, "+y1");

    // Special handling for increase cells
    if (cell.template.longname.includes("increase")) {
        addYarnsFromFaceForLayerVisibility(cell, "-y1");
        
        let topFaceIndex = getFaceIndex(cell, "+L1");
        const connectionTop = cell.connections[topFaceIndex];
        
        if (connectionTop && connectionTop.cell) {
            addYarnsFromFaceForLayerVisibility(connectionTop.cell, "-L1");
        }
    }

    // Special handling for decrease cells
    if (cell.template.longname.includes("decrease")) {
        addYarnsFromFaceForLayerVisibility(cell, "-d1");
        addYarnsFromFaceForLayerVisibility(cell, "+d1");
        addYarnsFromFaceForLayerVisibility(cell, "-d2");
        addYarnsFromFaceForLayerVisibility(cell, "+d2");
        
        // Handle connections
        const plusD1FaceIndex = getFaceIndex(cell, "+d1");
        if (plusD1FaceIndex !== -1 && cell.connections[plusD1FaceIndex]) {
            addYarnsFromFaceForLayerVisibility(cell.connections[plusD1FaceIndex].cell, "-d1");
        }
        
        const minusD2FaceIndex = getFaceIndex(cell, "-d2");
        if (minusD2FaceIndex !== -1 && cell.connections[minusD2FaceIndex]) {
            addYarnsFromFaceForLayerVisibility(cell.connections[minusD2FaceIndex].cell, "+d2");
        }
    }

    // Add yarns from final connected items
    if (currentConnectedItem && currentConnectedItem.cell && 
        currentConnectedItem.cell.template.longname.includes("knit.")) {
        addYarnsFromFaceForLayerVisibility(currentConnectedItem.cell, "-l1");
    }

    if (currentConnectedItemY1 && currentConnectedItemY1.cell && 
        currentConnectedItemY1.cell.template.longname.includes("knit.")) {
        addYarnsFromFaceForLayerVisibility(currentConnectedItemY1.cell, "-y1");
    }

    // Add loop head yarns
    if (loopHeadItem) {
        addYarnsFromFaceForLayerVisibility(loopHeadItem.cell, "-L1");
    }

    return visibleYarns;
}
/* ----- functions to control yarn-based layer visibility. end----- */

/* ----- functions to add bind-off. start ----- */
/**
 * addBindOff - Add bind-off blocks to the final row of the final layer
 */
function addBindOff() {
    const path = window.path || determinePath();
    if (path.length === 0) return;
    
    // Find the final layer index
    const finalLayerIndex = Math.max(...path.map(item => item.layerIndex));
    
    // Get all cells in the final layer
    const finalLayerCells = path.filter(item => item.layerIndex === finalLayerIndex);
    
    if (finalLayerCells.length === 0) return;
    
    // Find the final row index in the final layer
    const finalRowIndex = Math.max(...finalLayerCells.map(item => item.rowIndex));
    
    // Get all cells in the final row of the final layer
    const finalRowCells = finalLayerCells.filter(item => item.rowIndex === finalRowIndex);
    
    if (finalRowCells.length === 0) return;
        
    let addedBindOffCount = 0;
    
    // Process each cell in the final row
    finalRowCells.forEach(pathItem => {
        const cell = pathItem.cell;
        const direction = pathItem.direction;
        
        // Find +l1 face (front face)
        const frontFaceIndex = getFaceIndex(cell, "+l1");
        
        if (frontFaceIndex !== -1 && !cell.connections[frontFaceIndex]) {
            // Determine bind-off template based on direction
            let bindOffTemplateName;
            if (direction === "right") {
                bindOffTemplateName = "bind-off-through-down.left";
            } else if (direction === "left") {
                bindOffTemplateName = "bind-off-through-down.right";
            } else {
                console.warn(`Unknown direction "${direction}" for cell in final row`);
                return;
            }
            
            const bindOffTemplate = library.getTemplateByLongname(bindOffTemplateName);
            if (!bindOffTemplate) {
                console.error(`Template "${bindOffTemplateName}" not found in library`);
                return;
            }
            
            // Try to place bind-off using checkTemplateCompatible
            const bindOffCell = checkTemplateCompatible(cell, frontFaceIndex, bindOffTemplate);
            
            if (bindOffCell) {
                // Find the compatible face in bind-off template
                const bindOffInputFace = findCompatibleFace(bindOffTemplate, cell.template.faces[frontFaceIndex]);
                
                if (bindOffInputFace !== -1) {
                    // Establish bidirectional connection
                    cell.connections[frontFaceIndex] = {
                        cell: bindOffCell,
                        face: bindOffInputFace
                    };
                    bindOffCell.connections[bindOffInputFace] = {
                        cell: cell,
                        face: frontFaceIndex
                    };
                    
                    body.cells.push(bindOffCell);
                    addedBindOffCount++;
                    
                } else {
                    console.error(`Could not find compatible face in ${bindOffTemplateName} template`);
                }
            } else {
                console.error(`Could not position ${bindOffTemplateName} on cell with template ${cell.template.longname}`);
            }
        }
    });
    
    
    if (addedBindOffCount > 0) {
        bodyDirty();
        requestRedraw();
    }
    
    return addedBindOffCount;
}
/* ----- functions to add bind-off. end ----- */


/* ----- functions to add yarn-in and yarn-out. start ----- */
/**
 * addYarnInOut - Add yarn-in at the beginning and yarn-out at the end of the pattern
 */
function addYarnInOut() {
    const path = window.path || determinePath();
    if (path.length === 0) return;
    
    // Add yarn-in at the beginning
    const firstPathItem = path[0];
    if (firstPathItem) {
        const firstCell = firstPathItem.cell;
        const firstDirection = firstPathItem.direction;
        const yarnInTemplateName = firstDirection === "right" ? "yarn-in.right" : "yarn-in.left";
        
        addNewCellToTarget(firstCell, "-y1", yarnInTemplateName, "+y1");
    }
    
    // Add yarn-out at the end
    const lastPathItem = path[path.length - 1];
    if (lastPathItem) {
        const lastCell = lastPathItem.cell;
        const lastDirection = lastPathItem.direction;
        const yarnOutTemplateName = lastDirection === "right" ? "yarn-out.right" : "yarn-out.left";
        
        addNewCellToTarget(lastCell, "+y1", yarnOutTemplateName, "-y1");
    }
    
    determinePath();
    bodyDirty();
}
/* ----- functions to add yarn-in and yarn-out. end ----- */

</script>

</body>
</html>